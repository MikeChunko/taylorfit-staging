!function(){this.global=this,this.window=this}(),function(n){function t(r){if(e[r])return e[r].exports;var a=e[r]={i:r,l:!1,exports:{}};return n[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}var e={};t.m=n,t.c=e,t.i=function(n){return n},t.d=function(n,e,r){t.o(n,e)||Object.defineProperty(n,e,{configurable:!1,enumerable:!0,get:r})},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},t.p="",t(t.s=162)}({162:/*!*******************************************!*\
  !*** ./engine/worker/candidate-worker.js ***!
  \*******************************************/
function(module,exports,__webpack_require__){eval("/*global postMessage, onmessage*/\n\nif (typeof window !== 'undefined') {\n  __webpack_require__(/*! ./subworkers */ 26);\n}\n\nconst UPDATE_INTERVAL = 200;\n\nconst Matrix = __webpack_require__(/*! ../matrix */ 25);\nconst lstsq = __webpack_require__(/*! ../regression */ 60).lstsq;\nconst statistics = __webpack_require__(/*! ../statistics */ 50);\n\nonmessage = ({ data: { fit, cross, candidates, jobId } }) => {\n  fit.X = new Matrix(fit.X.m, fit.X.n, fit.X.data);\n  fit.y = new Matrix(fit.y.m, fit.y.n, fit.y.data);\n\n  if (cross !== fit) {\n    cross.X = new Matrix(cross.X.m, cross.X.n, cross.X.data);\n    cross.y = new Matrix(cross.y.m, cross.y.n, cross.y.data);\n  }\n\n  let model = { fit, cross };\n\n  let results = candidates.map(({ fit, cross, lag }, i) => {\n    // Can't find a fit if exponent is -1 and divisor is 0\n    if (!fit) {\n      return NaN;\n    }\n    // reconstruct matrices (they were deconstructed for transport)\n    fit = {\n      X: model.fit.X.hstack(new Matrix(fit.m, fit.n, fit.data)).lo(lag),\n      y: model.fit.y.lo(lag)\n    };\n    cross = {\n      X: model.cross.X.hstack(new Matrix(cross.m, cross.n, cross.data)).lo(lag),\n      y: model.cross.y.lo(lag)\n    };\n\n    if (i % UPDATE_INTERVAL === 0) {\n      postMessage({ type: 'progress', data: i, jobId });\n    }\n\n    try {\n      let regression = lstsq(fit.X, fit.y);\n\n      // Compute stats for fit, then take t and P(t) (these come from fit data)\n      let stats = statistics(regression);\n      let t = stats.t.get(0, stats.t.shape[0] - 1);\n      let pt = stats.pt.get(0, stats.pt.shape[0] - 1);\n\n      // Then, use the cross data to compute the rest of the statistics\n      Object.assign(regression, { X: cross.X, y: cross.y });\n\n      stats = statistics(regression);\n\n      stats.coeff = stats.weights.get(0, stats.weights.shape[0] - 1);\n      stats.t = t;\n      stats.pt = pt;\n      delete stats.weights;\n\n      return stats;\n    } catch (e) {\n      console.error(e);\n      return NaN;\n    }\n  });\n  postMessage({ type: 'result', data: results, jobId });\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/worker/candidate-worker.js\n// module id = 162\n// module chunks = 2\n\n//# sourceURL=webpack:///./engine/worker/candidate-worker.js?")},25:/*!********************************!*\
  !*** ./engine/matrix/index.js ***!
  \********************************/
function(module,exports,__webpack_require__){eval("\nmodule.exports = __webpack_require__(/*! ./Matrix */ 80);\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/matrix/index.js\n// module id = 25\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/matrix/index.js?")},26:/*!*************************************!*\
  !*** ./engine/worker/subworkers.js ***!
  \*************************************/
function(module,exports,__webpack_require__){eval("(function () {\n\n  /* Detect if we're in a worker or not */\n  var isWorker = false;\n  try {\n    document;\n  } catch (e) {\n    isWorker = true;\n  }\n\n  if (isWorker) {\n    // Replace self.postMessage because webpack-dev-server doesn't recognize\n    // workers\n    let oldPostMessage = self.postMessage;\n    self.postMessage = (msg, otherthing) => {\n      try {\n        oldPostMessage(msg, otherthing);\n      } catch (e) {\n        console.warn(e.message);\n      }\n    };\n\n    // For some reason, nested workers on firefox sucks. So, just polyfill all\n    // of the browsers to make this work\n    if (true /* we don't really need to check this */) {\n        self.Worker = function (path) {\n          var that = this;\n          this.id = Math.random().toString(36).substr(2, 5);\n\n          this.eventListeners = {\n            \"message\": []\n          };\n          self.addEventListener(\"message\", function (e) {\n            if (e.data._from === that.id) {\n              var newEvent = new MessageEvent(\"message\");\n              newEvent.initMessageEvent(\"message\", false, false, e.data.message, that, \"\", null, []);\n              that.dispatchEvent(newEvent);\n              if (that.onmessage) {\n                that.onmessage(newEvent);\n              }\n            }\n          });\n\n          var location = self.location.pathname;\n          var absPath = path; //location.substring(0, location.lastIndexOf('/')) + '/' + path;\n          self.postMessage({\n            _subworker: true,\n            cmd: 'newWorker',\n            id: this.id,\n            path: absPath\n          });\n        };\n        Worker.prototype = {\n          onerror: null,\n          onmessage: null,\n          postMessage: function (message) {\n            self.postMessage({\n              _subworker: true,\n              id: this.id,\n              cmd: 'passMessage',\n              message: message\n            });\n          },\n          terminate: function () {\n            self.postMessage({\n              _subworker: true,\n              cmd: 'terminate',\n              id: this.id\n            });\n          },\n          addEventListener: function (type, listener, useCapture) {\n            if (this.eventListeners[type]) {\n              this.eventListeners[type].push(listener);\n            }\n          },\n          removeEventListener: function (type, listener, useCapture) {\n            if (!(type in this.eventListeners)) return;\n            var index = this.eventListeners[type].indexOf(listener);\n            if (index !== -1) {\n              this.eventListeners[type].splice(index, 1);\n            }\n          },\n          dispatchEvent: function (event) {\n            var listeners = this.eventListeners[event.type];\n            for (var i = 0; i < listeners.length; i++) {\n              listeners[i](event);\n            }\n          }\n        };\n      }\n  }\n\n  var allWorkers = {};\n  var cmds = {\n    newWorker: function (event) {\n      var worker = new Worker(event.data.path);\n      worker.addEventListener(\"message\", function (e) {\n        var envelope = {\n          _from: event.data.id,\n          message: e.data\n        };\n        event.target.postMessage(envelope);\n      });\n      allWorkers[event.data.id] = worker;\n    },\n    terminate: function (event) {\n      allWorkers[event.data.id].terminate();\n    },\n    passMessage: function (event) {\n      allWorkers[event.data.id].postMessage(event.data.message);\n    }\n  };\n  var messageRecieved = function (event) {\n    if (event.data._subworker) {\n      cmds[event.data.cmd](event);\n    }\n  };\n\n  /* Hijack Worker */\n  var oldWorker = window.Worker;\n  window.Worker = function (path) {\n\n    var blobIndex = path.indexOf('blob:');\n\n    if (blobIndex !== -1 && blobIndex !== 0) {\n      path = path.substring(blobIndex);\n    }\n\n    var newWorker = new oldWorker(path);\n    newWorker.addEventListener(\"message\", messageRecieved);\n\n    return newWorker;\n  };\n})();\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/worker/subworkers.js\n// module id = 26\n// module chunks = 0 1 2 3\n\n//# sourceURL=webpack:///./engine/worker/subworkers.js?")},36:/*!*************************!*\
  !*** ./engine/utils.js ***!
  \*************************/
function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction nchars(n, char) {\n  n = Math.max(0, n);\n  return Array(n + 1).join(char);\n}\n\nlet nspaces = n => nchars(n, ' ');\n\nfunction pad(width, val) {\n  val = val || '';\n  return nspaces(width - ('' + val).length) + val;\n}\n\nlet range = module.exports.range = (start, end) => {\n  if (start >= end) {\n    return [];\n  }\n  return Array(end - start).join(' ').split(' ').map((_, i) => i + start);\n};\n\nlet zeros = module.exports.zeros = n => Array(n).join(' ').split(' ').map(() => 0);\n\nlet sum = module.exports.sum = arr => arr.reduce((tot, curr) => tot + curr);\n\nmodule.exports.convertRange = (str, length) => {\n  var range, start, end;\n\n  if (typeof str === 'number') {\n    return str < 0 ? [length + str] : [str];\n  }\n  if (typeof str !== 'string') {\n    return str.map(ind => ind < 0 ? length + ind : ind);\n  }\n\n  if ((range = str.split(':')).length > 1) {\n    start = parseInt(range[0]) || 0;\n    end = parseInt(range[1]) || length;\n\n    if (start < 0) {\n      start = length + start;\n    }\n    if (end < 0) {\n      end = length + end;\n    }\n    return module.exports.range(start, end);\n  }\n\n  throw new TypeError('Invalid range');\n};\n\nmodule.exports.formatNum = (leftwidth, rightwidth, val, nilDecimalChar = ' ') => {\n  val = '' + val;\n  var match = val.match(/(NaN|-?Infinity|-?\\d*)\\.?(\\d*)/),\n      whole = match[1],\n      frac = match[2],\n      repr = '';\n\n  if (frac.length > rightwidth) {\n    frac = frac.slice(0, rightwidth);\n  }\n  repr += nspaces(leftwidth - whole.length) + whole;\n  if (frac !== '' || rightwidth > 0) {\n    repr += '.';\n    repr += frac.slice(0, rightwidth) + nchars(rightwidth - frac.length, nilDecimalChar);\n  } else {\n    repr += nspaces(rightwidth + 1);\n  }\n  return repr;\n};\n\nlet padAll = module.exports.padAll = (lwidth, str) => {\n  if (Array.isArray(str)) {\n    return str.map(s => padAll(lwidth + s.length, s));\n  } else if (typeof str === 'string') {\n    return str.split('\\n').map(s => pad(lwidth + s.length, s)).join('\\n');\n  }\n  return pad(lwidth, str);\n};\n\nlet clone = module.exports.clone = obj => {\n  if (typeof obj !== 'object') {\n    return obj;\n  }\n  if (Array.isArray(obj)) {\n    return obj.map(clone);\n  }\n\n  let newObj = {};\n  Object.keys(obj).forEach(key => newObj[key] = clone(obj[key]));\n  return newObj;\n};\n\nlet split = module.exports.split = (arr, n) => {\n  let results = range(0, n).map(() => []);\n  let i;\n\n  for (i = 0; i < arr.length; i += 1) {\n    results[i % n].push(arr[i]);\n  }\n  return results;\n};\n\nlet splitToSize = module.exports.splitToSize = (arr, n) => {\n  let results = [];\n  let subset;\n  let i;\n\n  for (i = 0, subset = []; i < arr.length; i += 1) {\n    subset.push(arr[i]);\n    if ((i + 1) % n === 0) {\n      results.push(subset);\n      subset = [];\n    }\n  }\n  if (i % n !== 0) {\n    results.push(subset);\n  }\n  return results;\n};\n\nmodule.exports.join = arr => [].concat.apply([], arr);\n\nmodule.exports.sign = x => x < 0 ? -1 : x > 0 ? 1 : 0;\n\nmodule.exports.argmax = arr => arr.indexOf(Math.max.apply(null, arr));\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/utils.js\n// module id = 36\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/utils.js?")},50:/*!************************************!*\
  !*** ./engine/statistics/index.js ***!
  \************************************/
function(module,exports,__webpack_require__){eval("\nconst Statistic = __webpack_require__(/*! ./Statistic */ 55);\nconst topsort = __webpack_require__(/*! ./topsort */ 83);\nconst definitions = __webpack_require__(/*! ./definitions */ 82);\nconst metadata = __webpack_require__(/*! ./metadata.json */ 61);\n\n// used for t-stat calculations\n//let VdivwSq = V.dotDivide(w).dotPow(2);\n\nconst sorted = topsort(definitions);\n\nconst noShow = metadata.filter(({ show }) => !show);\n\nmodule.exports = predefinedStats => {\n  let stats = sorted.reduce((calculatedStats, stat) => stat.calc(calculatedStats), predefinedStats);\n\n  /*\r\n  for (let key of noShow) {\r\n    delete stats[key];\r\n  }\r\n   */\n\n  return stats;\n};\n\nmodule.exports.compute = (stat, args) => {\n  stat = definitions.find(s => s.name === stat);\n\n  if (stat == null) {\n    throw new ReferenceError('Cannot find statistic \\'' + stat + '\\'');\n  }\n\n  return stat.calc(args)[stat];\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/index.js\n// module id = 50\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/index.js?")},54:/*!************************************************!*\
  !*** ./engine/regression/svd-golub-reinsch.js ***!
  \************************************************/
function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Matrix = __webpack_require__(/*! ../matrix */ 25);\n\nfunction pythag(a, b) {\n  var absa = Math.abs(a),\n      absb = Math.abs(b);\n\n  return absa > absb ? absa * Math.sqrt(1 + Math.pow(absb / absa, 2)) : absb === 0 ? 0 : absb * Math.sqrt(1 + Math.pow(absa / absb, 2));\n}\n\n/**\r\n * Translation of the SVD algorithm published in Numer. Math. 14, 403-420 (1970)\r\n * by G. H. Golub and C. Reinsch.\r\n *\r\n * Source: http://cs.brown.edu/courses/csci0530/current/homeworks/svd.py\r\n *\r\n * @param {Matrix<m,n>} A Matrix to decompose (m >= n)\r\n * @return {[Matrix<m,m>, Matrix<m,n>, Matrix<n,n>]} [U, E, V] s.t. A = U*E*V\r\n */\nfunction svd(A) {\n  var eps = Number.EPSILON,\n      tol = Number.MIN_VALUE / eps;\n\n  if (1.0 + eps <= 1.0) {\n    throw new Error('Make eps bigger');\n  }\n  if (tol <= 0.0) {\n    throw new Error('Make tol bigger');\n  }\n\n  var itmax = 50,\n      u = A.clone(),\n      m = u.shape[0],\n      n = u.shape[1],\n      e = [],\n      q = [],\n      v = new Matrix(n, n),\n      g = 0.0,\n      x = 0.0,\n      i,\n      j,\n      k,\n      l,\n      s,\n      f,\n      h,\n      y,\n      iteration,\n      gotoTestFConvergence,\n      z,\n      c,\n      l1;\n\n  if (m < n) {\n    throw new Error('m is less than n');\n  }\n\n  for (i = 0; i < n; i++) {\n    e[i] = g;\n    s = 0.0;\n    l = i + 1;\n    for (j = i; j < m; j++) s += u.data[j * n + i] * u.data[j * n + i];\n    if (s < tol) {\n      g = 0.0;\n    } else {\n      f = u.data[i * n + i];\n      if (f < 0.0) {\n        g = Math.sqrt(s);\n      } else {\n        g = -Math.sqrt(s);\n      }\n      h = f * g - s;\n      u.data[i * n + i] = f - g;\n      for (j = l; j < n; j++) {\n        s = 0.0;\n        for (k = i; k < m; k++) s += u.data[k * n + i] * u.data[k * n + j];\n        f = s / h;\n        for (k = i; k < m; k++) u.data[k * n + j] = u.data[k * n + j] + f * u.data[k * n + i];\n      }\n    }\n    q[i] = g;\n    s = 0.0;\n    for (j = l; j < n; j++) s = s + u.data[i * n + j] * u.data[i * n + j];\n    if (s <= tol) {\n      g = 0.0;\n    } else {\n      f = u.data[i * n + i + 1];\n      if (f < 0.0) {\n        g = Math.sqrt(s);\n      } else {\n        g = -Math.sqrt(s);\n      }\n      h = f * g - s;\n      u.data[i * n + i + 1] = f - g;\n      for (j = l; j < n; j++) e[j] = u.data[i * n + j] / h;\n      for (j = l; j < m; j++) {\n        s = 0.0;\n        for (k = l; k < n; k++) s = s + u.data[j * n + k] * u.data[i * n + k];\n        for (k = l; k < n; k++) u.data[j * n + k] = u.data[j * n + k] + s * e[k];\n      }\n    }\n    y = Math.abs(q[i]) + Math.abs(e[i]);\n    if (y > x) {\n      x = y;\n    }\n  }\n  // accumulation of right hand transformations\n  for (i = n - 1; i > -1; i--) {\n    if (g !== 0) {\n      h = g * u.data[i * n + i + 1];\n      for (j = l; j < n; j++) v.data[j * n + i] = u.data[i * n + j] / h;\n      for (j = l; j < n; j++) {\n        s = 0.0;\n        for (k = l; k < n; k++) s += u.data[i * n + k] * v.data[k * n + j];\n        for (k = l; k < n; k++) v.data[k * n + j] += s * v.data[k * n + i];\n      }\n    }\n    for (j = l; j < n; j++) {\n      v.data[i * n + j] = 0.0;\n      v.data[j * n + i] = 0.0;\n    }\n    v.data[i * n + i] = 1.0;\n    g = e[i];\n    l = i;\n  }\n  // accumulation of left hand transformations\n  for (i = n - 1; i > -1; i--) {\n    l = i + 1;\n    g = q[i];\n    for (j = l; j < n; j++) u.data[i * n + j] = 0.0;\n    if (g !== 0.0) {\n      h = u.data[i * n + i] * g;\n      for (j = l; j < n; j++) {\n        s = 0.0;\n        for (k = l; k < m; k++) s += u.data[k * n + i] * u.data[k * n + j];\n        f = s / h;\n        for (k = i; k < m; k++) u.data[k * n + j] += f * u.data[k * n + i];\n      }\n      for (j = i; j < m; j++) u.data[j * n + i] = u.data[j * n + i] / g;\n    } else {\n      for (j = i; j < m; j++) u.data[j * n + i] = 0.0;\n    }\n    u.data[i * n + i] += 1.0;\n  }\n  // diagonalization of the bidiagonal form\n  eps = eps * x;\n  for (k = n - 1; k > -1; k--) {\n    for (iteration = 0; iteration < itmax; iteration++) {\n      // test f splitting\n      for (l = k; l > -1; l--) {\n        gotoTestFConvergence = false;\n        if (Math.abs(e[l]) <= eps) {\n          // goto test f convergence\n          gotoTestFConvergence = true;\n          break;\n        }\n        if (Math.abs(q[l - 1]) <= eps) {\n          // goto cancellation\n          break;\n        }\n      }\n      if (!gotoTestFConvergence) {\n        // cancellation of e[l] if l>0\n        c = 0.0;\n        s = 1.0;\n        l1 = l - 1;\n        for (i = l; i < k + 1; i++) {\n          f = s * e[i];\n          e[i] = c * e[i];\n          if (Math.abs(f) <= eps) {\n            // goto test f convergence\n            break;\n          }\n          g = q[i];\n          h = pythag(f, g);\n          q[i] = h;\n          c = g / h;\n          s = -f / h;\n          for (j = 0; j < m; j++) {\n            y = u.data[j * n + l1];\n            z = u.data[j * n + i];\n            u.data[j * n + l1] = y * c + z * s;\n            u.data[j * n + i] = -y * s + z * c;\n          }\n        }\n      }\n      // test f convergence\n      z = q[k];\n      if (l === k) {\n        // convergence\n        if (z < 0.0) {\n          // q[k] is made non-negative\n          q[k] = -z;\n          for (j = 0; j < n; j++) {\n            v.data[j * n + k] = -v.data[j * n + k];\n          }\n        }\n        break; // break out of iteration loop and move on to next k value\n      }\n      if (iteration >= itmax - 1) {\n        throw new Error('SVD: No convergence');\n      }\n      // shift from bottom 2x2 minor\n      x = q[l];\n      y = q[k - 1];\n      g = e[k - 1];\n      h = e[k];\n      f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);\n      g = pythag(f, 1.0);\n      if (f < 0) {\n        f = ((x - z) * (x + z) + h * (y / (f - g) - h)) / x;\n      } else {\n        f = ((x - z) * (x + z) + h * (y / (f + g) - h)) / x;\n      }\n      // next QR transformation\n      c = 1.0;\n      s = 1.0;\n      for (i = l + 1; i < k + 1; i++) {\n        g = e[i];\n        y = q[i];\n        h = s * g;\n        g = c * g;\n        z = pythag(f, h);\n        e[i - 1] = z;\n        c = f / z;\n        s = h / z;\n        f = x * c + g * s;\n        g = -x * s + g * c;\n        h = y * s;\n        y = y * c;\n        for (j = 0; j < n; j++) {\n          x = v.data[j * n + i - 1];\n          z = v.data[j * n + i];\n          v.data[j * n + i - 1] = x * c + z * s;\n          v.data[j * n + i] = -x * s + z * c;\n        }\n        z = pythag(f, h);\n        q[i - 1] = z;\n        c = f / z;\n        s = h / z;\n        f = c * g + s * y;\n        x = -s * g + c * y;\n        for (j = 0; j < m; j++) {\n          y = u.data[j * n + i - 1];\n          z = u.data[j * n + i];\n          u.data[j * n + i - 1] = y * c + z * s;\n          u.data[j * n + i] = -y * s + z * c;\n        }\n      }\n      e[l] = 0.0;\n      e[k] = f;\n      q[k] = x;\n      // goto test f splitting\n    }\n  }\n\n  return [u, q, v];\n}\n\nmodule.exports = svd;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/regression/svd-golub-reinsch.js\n// module id = 54\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/regression/svd-golub-reinsch.js?")},55:/*!****************************************!*\
  !*** ./engine/statistics/Statistic.js ***!
  \****************************************/
function(module,exports){eval("\nconst defaults = ['X', 'y', 'BHat'];\n\nclass Statistic {\n\n  constructor(name, args, fn, description) {\n    this.name = name;\n    this.args = args;\n    this.fn = fn;\n  }\n\n  calc(statistics) {\n    statistics[this.name] = this.fn(statistics);\n    return statistics;\n  }\n\n  inspect(depth, options = { stylize: x => '' + x }) {\n    return `${this.name}(${this.args})`;\n  }\n\n}\n\nmodule.exports = (...args) => new Statistic(...args);\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/Statistic.js\n// module id = 55\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/Statistic.js?")},56:/*!*************************************************!*\
  !*** ./engine/statistics/distributions-socr.js ***!
  \*************************************************/
function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction statcom(q, i, j, b) {\n  var zz = 1,\n      z = zz,\n      k = i;\n\n  while (k <= j) {\n    zz *= q * k / (k - b);\n    z += zz;\n    k += 2;\n  }\n  return z;\n}\n\n/**\r\n * Two sided T-distribution estimator.\r\n *\r\n * Source: https://github.com/SOCR/HTML5_WebSite\r\n *         (Applets/Normal_T_Chi2_F_Tables.html)\r\n * License: GNU LGPL\r\n *\r\n * @param {Number} t T-statistic for some independent variable\r\n * @param {Number} n Degrees of freedom\r\n * @return {Number} 2-tailed p-value for the t statistic ( Pr(t) )\r\n */\nfunction pt(t, n) {\n  t = Math.abs(t);\n\n  var w = t / Math.sqrt(n),\n      th = Math.atan(w);\n\n  if (n === 1) {\n    return 1 - th / (Math.PI / 2);\n  }\n\n  var sth = Math.sin(th),\n      cth = Math.cos(th);\n\n  if (n % 2 === 1) {\n    return 1 - (th + sth * cth * statcom(cth * cth, 2, n - 3, -1)) / (Math.PI / 2);\n  }\n  return 1 - sth * statcom(cth * cth, 1, n - 3, -1);\n}\n\n/**\r\n * Fisher's F-density estimator.\r\n *\r\n * Source: https://github.com/SOCR/HTML5_WebSite\r\n *         (Applets/Normal_T_Chi2_F_Tables.html)\r\n * License: GNU LGPL\r\n *\r\n * @param {Number} f  F value for the model\r\n * @param {Number} n1 # of terms in the model\r\n * @param {Number} n2 Degrees of freedom\r\n * @return {Number} Probability of (F < f)\r\n */\nfunction pf(f, n1, n2) {\n  var x = n2 / (n1 * f + n2);\n\n  if (n1 % 2 === 0) {\n    return statcom(1 - x, n2, n1 + n2 - 4, n2 - 2) * Math.pow(x, n2 / 2);\n  }\n  if (n2 % 2 === 0) {\n    return 1 - statcom(x, n1, n1 + n2 - 4, n1 - 2) * Math.pow(1 - x, n1 / 2);\n  }\n\n  var th = Math.atan(Math.sqrt(n1 * f / n2)),\n      a = th / (Math.PI / 2),\n      sth = Math.sin(th),\n      cth = Math.cos(th);\n\n  if (n2 > 1) {\n    a += sth * cth * statcom(cth * cth, 2, n2 - 3, -1) / (Math.PI / 2);\n  }\n  if (n1 === 1) {\n    return 1 - a;\n  }\n\n  var c = 4 * statcom(sth * sth, n2 + 1, n1 + n2 - 4, n2 - 2) * sth * Math.pow(cth, n2) / Math.PI;\n\n  if (n2 === 1) {\n    return 1 - a + c / 2;\n  }\n\n  var k = 2;\n\n  while (k <= (n2 - 1) / 2) {\n    c *= k / (k - 0.5);\n    k += 1;\n  }\n  return 1 - a + c;\n}\n\nmodule.exports.pt = pt;\nmodule.exports.pf = pf;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/distributions-socr.js\n// module id = 56\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/distributions-socr.js?")},60:/*!************************************!*\
  !*** ./engine/regression/index.js ***!
  \************************************/
function(module,exports,__webpack_require__){eval("\n// lstsqSVD | lstsqNE\nconst METHOD = 'lstsqSVD';\n\nmodule.exports.svd = __webpack_require__(/*! ./svd-golub-reinsch */ 54);\nmodule.exports.lstsq = __webpack_require__(/*! ./lstsq */ 81)[METHOD];\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/regression/index.js\n// module id = 60\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/regression/index.js?")},61:/*!*****************************************!*\
  !*** ./engine/statistics/metadata.json ***!
  \*****************************************/
function(module,exports){eval('module.exports = [{"id":"X","show":false},{"id":"y","show":false},{"id":"v","show":false},{"id":"w","show":false},{"id":"VdivwSq","show":false},{"id":"BHat","show":false},{"id":"yHat","show":false},{"id":"Vary","show":false},{"id":"nd","globalOnly":true,"format":"int"},{"id":"np","globalOnly":true,"format":"int"},{"id":"SSE","sort":">"},{"id":"TSS","globalOnly":true},{"id":"SSR"},{"id":"MSR","sort":">"},{"id":"MSE"},{"id":"Rsq","sort":"<"},{"id":"cRsq","sort":">"},{"id":"adjRsq","sort":"<"},{"id":"AIC","sort":">"},{"id":"BIC","sort":">"},{"id":"F","sort":"<"},{"id":"pF","displayName":"p(F)","sort":">"},{"id":"t","sort":"|<|","candidateOnly":true,"default":true},{"id":"pt","displayName":"p(t)","sort":">","candidateOnly":true,"default":true},{"id":"stdev","show":false},{"id":"mean","show":false},{"id":"weights","show":false}]\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/metadata.json\n// module id = 61\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/metadata.json?')},80:/*!*********************************!*\
  !*** ./engine/matrix/Matrix.js ***!
  \*********************************/
function(module,exports,__webpack_require__){eval("\nconst utils = __webpack_require__(/*! ../utils */ 36);\n\n/**\r\n * Private members\r\n *\r\n * @private\r\n */\nconst _data = Symbol('data');\nconst _m = Symbol('m');\nconst _n = Symbol('n');\n\n// Maximum number of decimal points to print\nconst PRINT_DECIMALS = 5;\n\n// Number.MAX_SAFE_INTEGER value [ i.e. doesn't support :( ]\nconst MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n/**\r\n * Swap rows `i` and `j` in matrix `m` in place.\r\n *\r\n * @param {Matrix} m\r\n * @param {number} i\r\n * @param {number} j\r\n */\nfunction swapRows(m, i, j) {\n  var k, temp;\n\n  for (k = 0; k < m[_n]; k += 1) {\n    temp = m[_data][j * m[_n] + k];\n    m[_data][j * m[_n] + k] = m[_data][i * m[_n] + k];\n    m[_data][i * m[_n] + k] = temp;\n  }\n}\n\n/**\r\n * Divide row `i` in both matrix `m` and matrix `inv` by `factor`.\r\n *\r\n * @param {Matrix} m\r\n * @param {Matrix} inv\r\n * @param {number} i\r\n * @param {number} j\r\n */\nfunction divideRow(m, inv, i, factor) {\n  var k, temp;\n\n  for (k = 0; k < m[_n]; k += 1) {\n    m[_data][i * m[_n] + k] /= factor;\n    inv[_data][i * m[_n] + k] /= factor;\n  }\n}\n\n/**\r\n * Subtract multiple of row `i` and column `j` from every row in `m` and `inv`.\r\n *\r\n * @param {Matrix} m\r\n * @param {Matrix} inv\r\n * @param {number} i\r\n * @param {number} j\r\n */\nfunction subtractRowMultiple(m, inv, i, j) {\n  var k, l, factor;\n\n  for (l = 0; l < m[_m]; l += 1) {\n    factor = m[_data][l * m[_n] + j];\n\n    if (l !== i) {\n      for (k = 0; k < m[_n]; k += 1) {\n        m[_data][l * m[_n] + k] -= m[_data][i * m[_n] + k] * factor;\n        inv[_data][l * m[_n] + k] -= inv[_data][i * m[_n] + k] * factor;\n      }\n    }\n  }\n}\n\n/**\r\n * A speedy 2-dimensional matrix implementation.\r\n *\r\n * @class Matrix\r\n */\nclass Matrix {\n\n  /**\r\n   * Creates a new Matrix of size <n, m>, using `stuff`.\r\n   *\r\n   * If `stuff` is a Float64Array, then the reference will be used. Otherwise,\r\n   * its contents will be copied into a new Float64Array.\r\n   *\r\n   * @param {number | number[][]}       n     Number of columns (or nested arrays\r\n   *                                          that look like a matrix)\r\n   * @param {number}                    m     Number of rows\r\n   * @param {Float64Array | number[][]} stuff Items to populate the matrix\r\n   */\n  constructor(m, n, stuff) {\n    if (m instanceof Matrix) {\n      return m;\n    }\n    if (Array.isArray(m)) {\n      return Matrix.from(m);\n    }\n    if (stuff != null) {\n      stuff = stuff instanceof Float64Array ? stuff : Float64Array.from(stuff);\n      if (stuff.length !== m * n) {\n        throw new Error('Array does not match the specified dimensions');\n      }\n    } else {\n      stuff = new Float64Array(m * n);\n    }\n\n    // Filter Out NaN Columns\n    let valid_columns = new Array(n).fill(true);\n    let valid_column_count = n;\n\n    //i: Iterate over columns\n    for (let i = 0; i < n; i++) {\n      // j: iterate over rows\n      for (let j = 0; j < m; j++) {\n        if (isNaN(stuff[j * n + i])) {\n          valid_columns[i] = false;\n          valid_column_count -= 1;\n          break;\n        }\n      }\n    }\n\n    // If NaN Column Found, create new Float64 Array & Populate\n    if (valid_column_count != n) {\n      let new_stuff = new Float64Array(valid_column_count * m);\n      let iterator = 0;\n      for (let i = 0; i < m * n; i++) {\n        let curr_col = i % n;\n        if (valid_columns[curr_col]) {\n          new_stuff[iterator++] = stuff[i];\n        }\n      }\n      stuff = new_stuff;\n      n = valid_column_count;\n    }\n\n    this[_data] = stuff;\n    this[_m] = m;\n    this[_n] = n;\n    return this;\n  }\n\n  /**\r\n   * Retrieve the element at the ith row and jth column.\r\n   *\r\n   * @param {number} i s.t. 0 <= i < m\r\n   * @param {number} j s.t. 0 <= i < n\r\n   * @return {number} Element at (i, j)\r\n   */\n  get(i, j) {\n    return this[_data][i * this[_n] + j];\n  }\n\n  /**\r\n   * Set the element at the ith row and jth column.\r\n   *\r\n   * @param {number} i s.t. 0 <= i < m\r\n   * @param {number} j s.t. 0 <= i < n\r\n   * @param {number} value To replace the existing one\r\n   * @return {number} Element at (i, j)\r\n   */\n  set(i, j, value) {\n    return this[_data][i * this[_n] + j] = value;\n  }\n\n  /**\r\n   * Performs element-wise addition between two matrices and returns a new copy.\r\n   *\r\n   * @param {number | Matrix<m,n>} other  Scalar or Matrix with equivalent\r\n   *                                      dimensions to this\r\n   * @return {Matrix<m,n>} this + other\r\n   * @throws {Error} If dimensions do not match\r\n   */\n  add(other) {\n    var sum = this.clone(),\n        i;\n\n    if (typeof other === 'number') {\n      for (i = 0; i < sum[_data].length; i += 1) {\n        sum[_data][i] += other;\n      }\n    } else {\n      if (this[_m] !== other[_m] || this[_n] !== other[_n]) {\n        throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_n] + ' !== ' + other[_m] + ' && ' + this[_m] + ' !== ' + other[_m]);\n      }\n\n      for (i = 0; i < sum[_data].length; i += 1) {\n        sum[_data][i] += other[_data][i];\n      }\n    }\n    return sum;\n  }\n\n  /**\r\n   * Performs element-wise subtraction between two matrices and returns a new\r\n   * copy.\r\n   *\r\n   * @param {number | Matrix<m,n>} other  Scalar or Matrix with equivalent\r\n   *                                      dimensions to this\r\n   * @return {Matrix<m,n>} this - other\r\n   * @throws {Error} If dimensions do not match\r\n   */\n  sub(other) {\n    var sum = this.clone(),\n        i;\n\n    if (typeof other === 'number') {\n      for (i = 0; i < sum[_data].length; i += 1) {\n        sum[_data][i] -= other;\n      }\n    } else {\n      if (this[_m] !== other[_m] || this[_n] !== other[_n]) {\n        throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_n] + ' !== ' + other[_m] + ' && ' + this[_m] + ' !== ' + other[_m]);\n      }\n\n      for (i = 0; i < sum[_data].length; i += 1) {\n        sum[_data][i] -= other[_data][i];\n      }\n    }\n    return sum;\n  }\n\n  /**\r\n   * Performs matrix multiplication between this and other.\r\n   *\r\n   * @param {Matrix<n,k>} other Matrix whose rows must be === to this's columns\r\n   * @return {Matrix<m,k>} this * other\r\n   * @throws {Error} If dimensions do not match\r\n   */\n  dot(other) {\n    if (this[_n] !== other[_m]) {\n      throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_n] + ' !== ' + other[_m]);\n    }\n\n    var product = new Matrix(this[_m], other[_n]),\n        i,\n        j,\n        k,\n        sum;\n\n    for (i = 0; i < this[_m]; i += 1) {\n      for (j = 0; j < other[_n]; j += 1) {\n        for (k = 0, sum = 0; k < this[_n]; k += 1) {\n          sum += this[_data][i * this[_n] + k] * other[_data][k * other[_n] + j];\n        }\n        product[_data][i * other[_n] + j] = sum;\n      }\n    }\n    return product;\n  }\n\n  /**\r\n   * Computes the inverse of the matrix (only if it is square!).\r\n   *\r\n   * @return {Matrix<m,n>} Inverse matrix s.t. this * inv(this) === I\r\n   * @throws {Error} If not a square matrix\r\n   */\n  inv() {\n    if (this[_m] !== this[_n]) {\n      throw new Error('Must be square');\n    }\n\n    var self = this.clone(),\n        inverse = Matrix.eye(this[_m], this[_n]),\n        i,\n        j,\n        k,\n        factor;\n\n    for (i = 0, j = 0; i < self[_m] && j < self[_n]; i += 1, j += 1) {\n      if (self[_data] === 0) {\n        for (k = 0; self[_data][k * self[_n] + j] !== 0 && k < self[_m]; k += 1);\n        if (k >= self[_m]) {\n          j += 1;\n          continue;\n        }\n        swapRows(self, j, k);\n        swapRows(inverse, j, k);\n      }\n      divideRow(self, inverse, j, self[_data][j * self[_n] + j]);\n      subtractRowMultiple(self, inverse, i, j);\n    }\n    return inverse;\n  }\n\n  /**\r\n   * Returns a copy of the matrix.\r\n   *\r\n   * @return {Matrix<m,n>} Fresh clone\r\n   */\n  clone() {\n    return new Matrix(this[_m], this[_n], this[_data].slice());\n  }\n\n  /**\r\n   * Horizontally stacks `other` and returns the new matrix.\r\n   *\r\n   * @param {Matrix<m,k>} other Matrix whose rows === this's rows\r\n   * @return {Matrix<m,n+k>} Horizontal concatenation of this and other\r\n   * @throws {Error} If dimensions do not match\r\n   */\n  hstack(other) {\n    if (this[_m] !== other[_m]) {\n      throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_m] + ' !== ' + other[_m]);\n    }\n\n    var newM = this[_n] + other[_n],\n        stacked = new Matrix(this[_m], newM),\n        i,\n        j;\n\n    for (i = 0; i < this[_m]; i += 1) {\n      for (j = 0; j < this[_n]; j += 1) {\n        stacked[_data][i * newM + j] = this[_data][i * this[_n] + j];\n      }\n      for (j = 0; j < other[_n]; j += 1) {\n        stacked[_data][i * newM + this[_n] + j] = other[_data][i * other[_n] + j];\n      }\n    }\n    return stacked;\n  }\n\n  /**\r\n   * Vertically stacks `other` and returns the new matrix.\r\n   *\r\n   * @param {Matrix<k,n>} other Matrix whose cols === this's cols\r\n   * @return {Matrix<m+k,n>} Vertical concatenation of this and other\r\n   * @throws {Error} If dimensions do not match\r\n   */\n  vstack(other) {\n    if (this[_n] !== other[_n]) {\n      throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_n] + ' !== ' + other[_n]);\n    }\n\n    var stacked = new Matrix(this[_m] + other[_m], this[_n]);\n\n    stacked[_data].subarray(0, this[_m] * this[_n]).set(this[_data]);\n    stacked[_data].subarray(this[_m] * this[_n]).set(other[_data]);\n    return stacked;\n  }\n\n  /**\r\n   * Performs element-wise exponentiation to the matrix and returns a new copy.\r\n   *\r\n   * @param {number} exponent Power to raise each element to\r\n   * @return {Matrix<m,n>} this[i,i]^exponent\r\n   */\n  dotPow(exponent) {\n    var powd = this.clone(),\n        i;\n\n    for (i = 0; i < powd[_data].length; i += 1) {\n      powd[_data][i] = Math.pow(powd[_data][i], exponent);\n      if (!Number.isFinite(powd[_data][i])) {\n        powd[_data][i] = MAX_SAFE_INTEGER;\n      }\n    }\n    return powd;\n  }\n\n  /**\r\n   * Performs element-wise multiplication to the matrix and returns a new copy.\r\n   *\r\n   * @param {number | Matrix} n Multiplicand to multiply each element by, or a\r\n   *                            matrix whose elements will be iterated through\r\n   *                            in alignment with this\r\n   * @return {Matrix<m,n>} this[i,i] * n   OR   this[i,i] * n[i,i]\r\n   */\n  dotMultiply(n) {\n    var product = this.clone(),\n        i;\n\n    if (typeof n === 'number') {\n      for (i = 0; i < product[_data].length; i += 1) {\n        product[_data][i] = product[_data][i] * n;\n      }\n    } else if (n instanceof Matrix) {\n      for (i = 0; i < product[_data].length; i += 1) {\n        product[_data][i] = product[_data][i] * n[_data][i];\n      }\n    }\n    return product;\n  }\n\n  /**\r\n   * Performs element-wise division to the matrix and returns a new copy.\r\n   *\r\n   * @param {number | Matrix} n Divisor to divide each element by, or a matrix\r\n   *                            whose elements will be iterated through in\r\n   *                            alignment with this\r\n   * @return {Matrix<m,n>} this[i,i] / n   OR   this[i,i] / n[i,i]\r\n   */\n  dotDivide(n) {\n    var product = this.clone(),\n        i,\n        j;\n\n    if (typeof n === 'number') {\n      for (i = 0; i < product[_data].length; i += 1) {\n        product[_data][i] = product[_data][i] / n;\n      }\n    } else if (n instanceof Matrix) {\n      for (i = 0, j = 0; i < product[_data].length; i += 1, j += 1) {\n        if (j >= n[_data].length) {\n          j = 0;\n        }\n        product[_data][i] = product[_data][i] / n[_data][j];\n      }\n    }\n    return product;\n  }\n\n  /**\r\n   * @see inspect\r\n   */\n  toString() {\n    return this.inspect();\n  }\n\n  /**\r\n   * Converts to nested array format\r\n   *\r\n   * @return {[][]} Nested arrays, where each child array is a row\r\n   */\n  toJSON() {\n    let i, rows;\n\n    for (i = 1, rows = []; i < this[_m]; i += 1) {\n      rows.push(Array.from(this[_data].slice((i - 1) * this[_n], i * this[_n])));\n    }\n    return rows;\n  }\n\n  /**\r\n   * Stringifies the matrix into a pretty format\r\n   *\r\n   * @return {string} Representation of the matrix\r\n   */\n  inspect(depth, options = { stylize: x => '' + x }) {\n    var repr = options.stylize(this.constructor.name, 'none'),\n        strings = Array.from(this[_data]).map(i => ('' + i).match(/(NaN|-?Infinity|-?\\d*)\\.?(\\d*)/)),\n        lwidth = Math.max.apply(null, strings.map(match => match[1].length)),\n        rwidth = Math.min(Math.max.apply(null, strings.map(match => match[2].length)), PRINT_DECIMALS),\n        rows = [],\n        i;\n\n    strings = Array.from(this[_data]).map(n => options.stylize(utils.formatNum(lwidth, rwidth, n), 'number'));\n\n    for (i = 0; i < this[_m]; i += 1) {\n      rows.push('[ ' + strings.slice(i * this[_n], (i + 1) * this[_n]).join(', ') + ' ]');\n    }\n\n    return repr + ' ' + utils.padAll(this.constructor.name.length + 1, rows.join('\\n')).trim();\n  }\n\n  /**\r\n   * Retrieves/sets the ith column of the matrix\r\n   *\r\n   * @param {number}    i         Column index\r\n   * @param {number[]}  [newCol]  Elements to replace the col with\r\n   * @return {Matrix<m,1>} Column as a matrix\r\n   */\n  col(i, newCol) {\n    var theCol = new Matrix(this[_m], 1),\n        k;\n\n    if (newCol != null) {\n      if (newCol.length > this[_m]) {\n        throw new RangeError('newCol cannot be longer than ' + this[_m]);\n      }\n      for (k = 0; k < this[_m]; k += 1) {\n        this[_data][k * this[_n] + i] = newCol[k];\n      }\n    }\n\n    for (k = 0; k < this[_m]; k += 1) {\n      theCol[_data][k] = this[_data][k * this[_n] + i];\n    }\n    return theCol;\n  }\n\n  /**\r\n   * Retrieves/sets the ith row of the matrix\r\n   *\r\n   * @param {number}    i         Row index\r\n   * @param {number[]}  [newRow]  Elements to replace the row with\r\n   * @return {Matrix<1,n>} Row as a matrix\r\n   */\n  row(i, newRow) {\n    if (newRow != null) {\n      if (newRow.length > this[_n]) {\n        throw new RangeError('newRow cannot be longer than ' + this[_n]);\n      }\n      this[_data].subarray(i * this[_n]).set(newRow);\n    }\n    return new Matrix(1, this[_n], this[_data].slice(i * this[_n], (i + 1) * this[_n]));\n  }\n\n  /**\r\n   * Retrieves a subset of the matrix, constructed from indices in `rows` and\r\n   * `cols`. The resulting matrix will have rows s.t. result[i] = this[rows[i]]\r\n   * and columns s.t. result[i][j] = this[rows[i][cols[j]]]\r\n   *\r\n   * @param {number[]} rows Array of indices used to construct the subset\r\n   * @param {number[]} cols Array of indices used to construct the subset\r\n   * @return {Matrix<rows.length, cols.length>} Subset of this\r\n   */\n  subset(rows = ':', cols = ':') {\n    rows = utils.convertRange(rows, this[_m]);\n    cols = utils.convertRange(cols, this[_n]);\n\n    var subMatrix = new Matrix(rows.length, cols.length),\n        i,\n        j;\n\n    for (i = 0; i < rows.length; i += 1) {\n      for (j = 0; j < cols.length; j += 1) {\n        subMatrix[_data][i * subMatrix[_n] + j] = this[_data][rows[i] * this[_n] + cols[j]];\n      }\n    }\n    return subMatrix;\n  }\n\n  // TODO: document\n  lo(row = 0) {\n    return new Matrix(this[_m] - row, this[_n], this[_data].slice(row * this[_n]));\n  }\n\n  // TODO: document\n  hi(row = 0) {\n    return new Matrix(row, this[_n], this[_data].slice(0, row * this[_n]));\n  }\n\n  // TODO: document\n  shift(rows) {\n    let newData = new Float64Array(this[_m] * this[_n]);\n    newData.subarray(this[_n] * rows).set(this[_data].subarray(0, -(this[_n] * rows) || this[_data].length));\n    return new Matrix(this[_n], this[_m], newData);\n  }\n\n  /**\r\n   * Retrieves the diagonal elements as a 1 x min(m, n) matrix.\r\n   *\r\n   * @return {Matrix<1,min(m,n)>} Diagonal elements\r\n   */\n  diag() {\n    var diagonal = new Matrix(1, Math.min(this[_m], this[_n])),\n        i;\n\n    for (i = 0; i < this[_m] && i < this[_n]; i += 1) {\n      diagonal[_data][i] = this[_data][i * this[_n] + i];\n    }\n    return diagonal;\n  }\n\n  /**\r\n   * Performs `Math.abs()` on each element then returns the resulting matrix.\r\n   *\r\n   * @return {Matrix<m,n>} A clone of `this`, but with the absolute value of\r\n   *                       each element\r\n   */\n  abs() {\n    var absolute = this.clone(),\n        i;\n\n    for (i = 0; i < absolute[_data].length; i += 1) {\n      absolute[_data][i] = Math.abs(absolute[_data][i]);\n    }\n    return absolute;\n  }\n\n  /**\r\n   * Sums all of the elements.\r\n   *\r\n   * @return {number} Sum of all of the elements\r\n   */\n  sum() {\n    var tot = 0,\n        i;\n\n    for (i = 0; i < this[_data].length; i += 1) {\n      tot += this[_data][i];\n    }\n    return tot;\n  }\n\n  /**\r\n   * Takes the product of all elements.\r\n   *\r\n   * @return {number} Product of all elements\r\n   */\n  prod() {\n    var tot = 1,\n        i;\n\n    for (i = 0; i < this[_data].length; i += 1) {\n      tot *= this[_data][i];\n    }\n    return tot;\n  }\n\n  /**\r\n   * Get minimum value in matrix\r\n   *\r\n   * @return {number} Minimum value\r\n   */\n  min() {\n    let i, min;\n\n    for (i = 0, min = Infinity; i < this[_data].length; i += 1) {\n      min = Math.min(min, this[_data][i]);\n    }\n    return min;\n  }\n\n  /**\r\n   * Get maximum value in matrix\r\n   *\r\n   * @return {number} Maximum value\r\n   */\n  max() {\n    let i, max;\n\n    for (i = 0, max = -Infinity; i < this[_data].length; i += 1) {\n      max = Math.max(max, this[_data][i]);\n    }\n    return max;\n  }\n\n  /**\r\n   * @property {Matrix<n,m>} T The transposition of the matrix\r\n   */\n  get T() {\n    var transpose = new Matrix(this[_n], this[_m]),\n        i,\n        j;\n\n    for (i = 0; i < this[_m]; i += 1) {\n      for (j = 0; j < this[_n]; j += 1) {\n        transpose[_data][j * this[_m] + i] = this[_data][i * this[_n] + j];\n      }\n    }\n    return transpose;\n  }\n\n  /**\r\n   * @property {[number, number]} shape The shape of this matrix [m, n]\r\n   */\n  get shape() {\n    return [this[_m], this[_n]];\n  }\n\n  /**\r\n   * @property {Float64Array} data The underlying storage for the matrix\r\n   */\n  get data() {\n    return this[_data];\n  }\n\n  /**\r\n   * Generates a matrix full of random (0, 1) numbers.\r\n   *\r\n   * @static\r\n   * @return {Matrix<m,n>} Matrix full'a random numbas\r\n   */\n  static random(m, n) {\n    var randMatrix = new Matrix(m, n),\n        i,\n        j;\n\n    for (i = 0; i < m; i += 1) {\n      for (j = 0; j < n; j += 1) {\n        randMatrix[_data][i * n + j] = Math.random();\n      }\n    }\n    return randMatrix;\n  }\n\n  /**\r\n   * Generates a matrix whose diagonal elements equal 1.\r\n   *\r\n   * @static\r\n   * @return {Matrix<m,n>} Diagonal onez\r\n   */\n  static eye(m, n = m) {\n    var onez = new Matrix(m, n),\n        i,\n        j;\n\n    for (i = 0; i < m; i += 1) {\n      onez[_data][i * n + i] = 1;\n    }\n    return onez;\n  }\n\n  /**\r\n   * Creates a matrix from matrix-looking nested arrays, or a flat array and the\r\n   * given `m` and `n`.\r\n   *\r\n   * @param {iterable | Matrix} arr Values to populate the matrix with\r\n   * @param {number}            m   Rows in the new matrix\r\n   * @param {number}            n   Columns in the new matrix\r\n   */\n  static from(arr, m, n) {\n    if (arr instanceof Matrix) {\n      return arr.clone();\n    }\n    if (!Array.isArray(arr)) {\n      throw new TypeError('Expected an array or Matrix');\n    }\n    if (arr.length <= 0) {\n      return new Matrix(0, 0);\n    }\n\n    var i;\n\n    m = m || arr.length;\n    n = n || arr[0].length;\n\n    // handed a 1-d array\n    if (arr[0].length == null) {\n      return new Matrix(1, arr.length, Float64Array.from(arr));\n    }\n\n    // otherwise, it's a 2-d array (and hopefully not >2-d)\n    for (i = 0; i < arr.length; i += 1) {\n      if (arr[i].length !== n) {\n        throw new Error('All rows must have equal length');\n      }\n    }\n    return new Matrix(m, n, Float64Array.from(utils.join(arr)));\n  }\n\n  /**\r\n   * Creates a matrix using `arr` to fill the diagonal elements in order.\r\n   *\r\n   * @param {number[m]} arr Array of numbers\r\n   * @returns {Matrix<m,m>} Matrix consisting only of the diagonal elements\r\n   */\n  static diag(arr) {\n    var m = arr.length,\n        mat = new Matrix(m, m),\n        i;\n\n    for (i = 0; i < m; i += 1) {\n      mat.data[i * m + i] = arr[i];\n    }\n    return mat;\n  }\n\n  static zeros(m, n = m) {\n    return this.eye(m, n).dotMultiply(0);\n  }\n\n}\n\nmodule.exports = Matrix;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/matrix/Matrix.js\n// module id = 80\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/matrix/Matrix.js?")},81:/*!************************************!*\
  !*** ./engine/regression/lstsq.js ***!
  \************************************/
function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Matrix = __webpack_require__(/*! ../matrix */ 25);\nconst svd = __webpack_require__(/*! ./svd-golub-reinsch */ 54);\nconst statistics = __webpack_require__(/*! ../statistics */ 50);\nconst dist = __webpack_require__(/*! ../statistics/distributions-socr */ 56);\nconst utils = __webpack_require__(/*! ../utils */ 36);\n\n/**\r\n * Computes total least squares regression on the matrix `A`, already decomposed\r\n * using SVD into the constituent `U`, `S` (sigma), and `V` matrices.\r\n *\r\n * @param {Matrix<m,n>} A Data matrix\r\n * @param {Matrix<m,m>} U U matrix resulting from SVD\r\n * @param {Matrix<m,n>} S Diagonal sigma matrix resulting from SVD\r\n * @param {Matrix<n,n>} V V matrix resulting from SVD\r\n * @param {Matrix<m,1>} b Independent column\r\n * @return {Matrix<n,1>} Estimated weight vector for the parameters (cols) in A\r\n */\nfunction lstsqSVD(A, U, S, V, b) {\n  var s = S,\n      m = A.shape[0],\n      n = A.shape[1],\n      eps = Number.EPSILON,\n      efcols = [],\n      maxEig = Math.max.apply(null, s.data),\n      i,\n      d,\n      x;\n\n  for (i = 0; i < n; i++) {\n    if (s.data[i] < Math.max(m, n) * eps * maxEig) {\n      s.data[i] = 0;\n    }\n  }\n  d = U.T.dot(b);\n  d = d.dotDivide(s);\n  for (i = 0; i < n; i++) {\n    if (Math.abs(d.data[i]) === Infinity) {\n      d.data[i] = 0;\n    }\n  }\n  x = V.dot(d);\n  return x;\n}\n\n/**\r\n * Compute least squares regression using normal equations, then compute\r\n * analytical statistics to determine the quality of the fit for the model and\r\n * for each term in the model.\r\n *\r\n *    B'      = inv(X'X)X'y                       <-- weight vector\r\n *    y'      = XB'\r\n *\r\n *    Nd      = # of data\r\n *    Np      = # of params (coefs) in model\r\n *\r\n *    SSE     = sum((y - y')^2)                   ^2 is element-wise\r\n *    TSS     = sum((y - mean(y))^2)\r\n *    SSR     = TSS - SSE\r\n *    Var y   = TSS / (Nd - 1)\r\n *    MSR     = SSR / (Np - 1)\r\n *    MSE     = SSE / (Nd - Np)\r\n *    RSQ     = 1 - (SSE / TSS)\r\n *    cRSQ    = 1 - R^2\r\n *    adj-RSQ = 1 - (MSE / Var y)\r\n *    F       = MSR / MSE\r\n *    AIC     = log(MSE) + 2*(Np/Nd)\r\n *    BIC     = log(MSE) + Np*log(Nd)/Nd\r\n *    t_i     = B' / sqrt( inv(X'X)[i,i] * MSE )   / is element-wise\r\n *\r\n * @return {object} Regression results\r\n */\nfunction lstsqNEWithStats(X, y) {\n  var XT = X.T,\n      pseudoInverse = XT.dot(X).inv(),\n      BHat = pseudoInverse.dot(XT).dot(y),\n      yHat = X.dot(BHat)\n\n  // fit statistics\n  ,\n      nd = X.shape[0],\n      np = X.shape[1],\n      sse = y.sub(yHat).dotPow(2).sum(),\n      tss = y.sub(y.sum() / y.shape[0]).dotPow(2).sum(),\n      ssr = tss - sse,\n      vary = tss / (nd - 1),\n      msr = ssr / (np - 1),\n      mse = sse / (nd - np),\n      rsq = 1 - sse / tss,\n      crsq = 1 - rsq,\n      adjrsq = 1 - mse / vary,\n      f = msr / mse,\n      aic = Math.log10(mse) + 2 * (np / nd),\n      bic = Math.log10(mse) + np * (Math.log10(nd) / nd)\n\n  // for t-statistics\n  ,\n      rtmse = Math.sqrt(mse),\n      sec = pseudoInverse.diag().abs().dotPow(0.5).dotMultiply(rtmse),\n      tstats = BHat.dotDivide(sec),\n      pts = tstats.clone();\n\n  pts.data.set(pts.data.map(t => dist.pt(t, nd - np)));\n\n  return {\n    weights: BHat,\n    tstats: tstats,\n    mse: mse,\n    rsq: rsq,\n    crsq: crsq,\n    adjrsq: adjrsq,\n    f: f,\n    pf: dist.pf(f, np, nd - np),\n    aic: aic,\n    bic: bic,\n    pts: pts\n  };\n}\n\nfunction scale(X) {\n  let stdevs = [];\n  let means = [];\n  let intercept = -1;\n  let i;\n\n  for (i = 0; i < X.shape[1]; i += 1) {\n    let col = X.col(i);\n    let nd = col.shape[0];\n    let mean = col.sum() / nd;\n    let newCol = col.sub(mean);\n    let stdev = Math.sqrt(newCol.dotPow(2).sum() / (nd - 1));\n\n    means.push(mean);\n\n    if (stdev <= Number.EPSILON && mean === 1) {\n      stdevs.push(1);\n      intercept = i;\n    } else {\n      X.col(i, newCol.dotDivide(stdev).data);\n      stdevs.push(stdev);\n    }\n  }\n\n  return {\n    stdev: new Matrix(stdevs).T,\n    mean: new Matrix(means).T,\n    intercept\n  };\n}\n\n/**\r\n * Compute least squares regression using singular value decomposition, then\r\n * compute analytical statistics to determine the quality of the fit for the\r\n * model and for each term in the model.\r\n *\r\n *    U, s, V = svd(X)\r\n *    B'      = V(U'b ./ s)                       See svd.lstsq for more\r\n *    y'      = XB'\r\n *\r\n * @return {object} Regression results\r\n */\nfunction lstsqSVDWithStats(X, y, predictors) {\n  let i;\n  let stdev = 1,\n      mean = 0,\n      intercept = -1;\n  //let { stdev, mean, intercept } = scale(X);\n\n  let decomposition = svd(X),\n      U = decomposition[0],\n      w = Matrix.from(decomposition[1]),\n      V = decomposition[2],\n      VdivwSq = V.dotDivide(w).dotPow(2),\n      BHat = predictors || lstsqSVD(X, U, w, V, y),\n      weights = BHat.dotDivide(stdev);\n\n  // If there is an intercept, un-scale its weight by subtracting the means of\n  // the other columns times the corresponding sign of their weights\n  //\n  //          B_0 = B_0 - sum(mean(i) * sign(weights(i)))\n  //\n  if (intercept >= 0) {\n    let interceptWeight = weights.get(0, intercept) + 1;\n\n    for (i = 0; i < weights.shape[0]; i += 1) {\n      interceptWeight -= mean.data[i] * utils.sign(weights.data[i]);\n    }\n    weights.data[intercept] = interceptWeight;\n  }\n\n  // Remove infinitely high values to work around potential divide-by-zero issue\n  for (i = 0; i < VdivwSq.data.length; i += 1) {\n    if (Math.abs(VdivwSq.data[i]) === Infinity || isNaN(VdivwSq.data[i])) {\n      VdivwSq.data[i] = 0;\n    }\n  }\n\n  return { X, y, BHat, VdivwSq, stdev, mean, weights, V, w };\n}\n\nmodule.exports.lstsqSVD = lstsqSVDWithStats;\nmodule.exports.lstsqNE = lstsqNEWithStats;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/regression/lstsq.js\n// module id = 81\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/regression/lstsq.js?")},82:/*!******************************************!*\
  !*** ./engine/statistics/definitions.js ***!
  \******************************************/
function(module,exports,__webpack_require__){eval("\nconst Statistic = __webpack_require__(/*! ./Statistic */ 55);\nconst Matrix = __webpack_require__(/*! ../matrix */ 25);\nconst dist = __webpack_require__(/*! ./distributions-socr */ 56);\n\n// Functional definitions for statistics -- defines how they will be calculated\n// NOTE: Make sure each statistic has an entry in `metadata.json`\nmodule.exports = [\n// given\nStatistic('X', [], ({ X }) => X), Statistic('y', [], ({ y }) => y), Statistic('BHat', [], ({ BHat }) => BHat), Statistic('yHat', ['X', 'BHat'], ({ X, BHat }) => X.dot(BHat)),\n\n// fit statistics\nStatistic('nd', ['X'], ({ X }) => X.shape[0]), Statistic('np', ['X'], ({ X }) => X.shape[1]), Statistic('SSE', ['y', 'yHat'], ({ y, yHat }) => y.sub(yHat).dotPow(2).sum()), Statistic('TSS', ['y'], ({ y }) => y.sub(y.sum() / y.shape[0]).dotPow(2).sum()),\n\n// yHat.sub(y.sum() / y.shape[0]).dotPow(2).sum()));\nStatistic('SSR', ['TSS', 'SSE'], ({ TSS, SSE }) => TSS - SSE), Statistic('Vary', ['TSS', 'nd'], ({ TSS, nd }) => TSS / (nd - 1)), Statistic('MSR', ['SSR', 'np'], ({ SSR, np }) => SSR / (np - 1)), Statistic('MSE', ['SSE', 'nd', 'np'], ({ SSE, nd, np }) => SSE / (nd - np)), Statistic('Rsq', ['SSE', 'TSS'], ({ SSE, TSS }) => 1 - SSE / TSS), Statistic('cRsq', ['Rsq'], ({ Rsq }) => 1 - Rsq), Statistic('adjRsq', ['Rsq', 'np', 'nd'], ({ Rsq, nd, np }) => 1 - (1 - Rsq) * (nd - 1) / (nd - np)), Statistic('F', ['MSR', 'MSE'], ({ MSR, MSE }) => MSR / MSE), Statistic('AIC', ['MSE', 'np', 'nd'], ({ MSE, np, nd }) => Math.log10(MSE) + 2 * (np / nd)), Statistic('BIC', ['MSE', 'np', 'nd'], ({ MSE, np, nd }) => Math.log10(MSE) + np * (Math.log10(nd) / nd)), Statistic('t', ['X', 'VdivwSq', 'MSE', 'BHat'], ({ X, VdivwSq, MSE, BHat }) => {\n  var sec = new Matrix(1, X.shape[1]),\n      stdModelErr,\n      i;\n\n  for (i = 0; i < X.shape[1]; i += 1) {\n    stdModelErr = Math.sqrt(VdivwSq.row(i).sum() * MSE);\n    sec.data[i] = stdModelErr;\n  }\n\n  return BHat.dotDivide(sec);\n}), Statistic('pt', ['t', 'np', 'nd'], ({ t, np, nd }) => {\n  let pt = t.clone();\n  pt.data.set(pt.data.map(t => Math.max(0, dist.pt(t, nd - np))));\n  return pt;\n}), Statistic('pF', ['F', 'np', 'nd'], ({ F, np, nd }) => dist.pf(Math.abs(F), np, nd - np))];\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/definitions.js\n// module id = 82\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/definitions.js?")},83:/*!**************************************!*\
  !*** ./engine/statistics/topsort.js ***!
  \**************************************/
function(module,exports){eval("\nconst inDegree = (stat, statistics) => {\n  let names = statistics.map(({ name }) => name);\n  return stat.args.filter(s => names.includes(s)).length;\n};\n\nconst topsort = statistics => {\n  let S = statistics.filter(stat => stat.args.length === 0);\n  let L = [];\n  let remaining = statistics.filter(stat => !S.includes(stat));\n  let node;\n\n  while (S.length > 0) {\n    node = S.shift();\n    remaining = remaining.filter(n => n !== node);\n    L.push(node);\n    S = S.concat(remaining.filter(stat => inDegree(stat, remaining) === 0));\n    remaining = remaining.filter(stat => !S.includes(stat));\n  }\n  if (remaining.length > 0) {\n    throw new Error('Statistics are co-dependent');\n  }\n  return L;\n};\n\nmodule.exports = topsort;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/topsort.js\n// module id = 83\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/topsort.js?")}});