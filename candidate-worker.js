!function(){this.global=this,this.window=this}(),function(n){function t(r){if(e[r])return e[r].exports;var a=e[r]={i:r,l:!1,exports:{}};return n[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}var e={};t.m=n,t.c=e,t.d=function(n,e,r){t.o(n,e)||Object.defineProperty(n,e,{configurable:!1,enumerable:!0,get:r})},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},t.p="",t(t.s=397)}({108:/*!*************************************!*\
  !*** ./engine/worker/subworkers.js ***!
  \*************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){eval("(function () {\n  /* Detect if we're in a worker or not */\n  var isWorker = false;\n\n  try {\n    document;\n  } catch (e) {\n    isWorker = true;\n  }\n\n  if (isWorker) {\n    // Replace self.postMessage because webpack-dev-server doesn't recognize\n    // workers\n    var oldPostMessage = self.postMessage;\n\n    self.postMessage = function (msg, otherthing) {\n      try {\n        oldPostMessage(msg, otherthing);\n      } catch (e) {\n        console.warn(e.message);\n      }\n    }; // For some reason, nested workers on firefox sucks. So, just polyfill all\n    // of the browsers to make this work\n\n\n    if (true\n    /* we don't really need to check this */\n    ) {\n        self.Worker = function (path) {\n          var that = this;\n          this.id = Math.random().toString(36).substr(2, 5);\n          this.eventListeners = {\n            \"message\": []\n          };\n          self.addEventListener(\"message\", function (e) {\n            if (e.data._from === that.id) {\n              var newEvent = new MessageEvent(\"message\");\n              newEvent.initMessageEvent(\"message\", false, false, e.data.message, that, \"\", null, []);\n              that.dispatchEvent(newEvent);\n\n              if (that.onmessage) {\n                that.onmessage(newEvent);\n              }\n            }\n          });\n          var location = self.location.pathname;\n          var absPath = path; //location.substring(0, location.lastIndexOf('/')) + '/' + path;\n\n          self.postMessage({\n            _subworker: true,\n            cmd: 'newWorker',\n            id: this.id,\n            path: absPath\n          });\n        };\n\n        Worker.prototype = {\n          onerror: null,\n          onmessage: null,\n          postMessage: function postMessage(message) {\n            self.postMessage({\n              _subworker: true,\n              id: this.id,\n              cmd: 'passMessage',\n              message: message\n            });\n          },\n          terminate: function terminate() {\n            self.postMessage({\n              _subworker: true,\n              cmd: 'terminate',\n              id: this.id\n            });\n          },\n          addEventListener: function addEventListener(type, listener, useCapture) {\n            if (this.eventListeners[type]) {\n              this.eventListeners[type].push(listener);\n            }\n          },\n          removeEventListener: function removeEventListener(type, listener, useCapture) {\n            if (!(type in this.eventListeners)) return;\n            var index = this.eventListeners[type].indexOf(listener);\n\n            if (index !== -1) {\n              this.eventListeners[type].splice(index, 1);\n            }\n          },\n          dispatchEvent: function dispatchEvent(event) {\n            var listeners = this.eventListeners[event.type];\n\n            for (var i = 0; i < listeners.length; i++) {\n              listeners[i](event);\n            }\n          }\n        };\n      }\n  }\n\n  var allWorkers = {};\n  var cmds = {\n    newWorker: function newWorker(event) {\n      var worker = new Worker(event.data.path);\n      worker.addEventListener(\"message\", function (e) {\n        var envelope = {\n          _from: event.data.id,\n          message: e.data\n        };\n        event.target.postMessage(envelope);\n      });\n      allWorkers[event.data.id] = worker;\n    },\n    terminate: function terminate(event) {\n      allWorkers[event.data.id].terminate();\n    },\n    passMessage: function passMessage(event) {\n      allWorkers[event.data.id].postMessage(event.data.message);\n    }\n  };\n\n  var messageRecieved = function messageRecieved(event) {\n    if (event.data._subworker) {\n      cmds[event.data.cmd](event);\n    }\n  };\n  /* Hijack Worker */\n\n\n  var oldWorker = window.Worker;\n\n  window.Worker = function (path) {\n    var blobIndex = path.indexOf('blob:');\n\n    if (blobIndex !== -1 && blobIndex !== 0) {\n      path = path.substring(blobIndex);\n    }\n\n    var newWorker = new oldWorker(path);\n    newWorker.addEventListener(\"message\", messageRecieved);\n    return newWorker;\n  };\n})();\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/worker/subworkers.js\n// module id = 108\n// module chunks = 0 1 2 3\n\n//# sourceURL=webpack:///./engine/worker/subworkers.js?")},121:/*!************************************!*\
  !*** ./engine/statistics/index.js ***!
  \************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){eval("var Statistic = __webpack_require__(/*! ./Statistic */ 140);\n\nvar topsort = __webpack_require__(/*! ./topsort */ 206);\n\nvar definitions = __webpack_require__(/*! ./definitions */ 207);\n\nvar metadata = __webpack_require__(/*! ./metadata.json */ 168); // used for t-stat calculations\n//let VdivwSq = V.dotDivide(w).dotPow(2);\n\n\nvar sorted = topsort(definitions);\nvar noShow = metadata.filter(function (_ref) {\n  var show = _ref.show;\n  return !show;\n});\n\nmodule.exports = function (predefinedStats) {\n  var stats = sorted.reduce(function (calculatedStats, stat) {\n    return stat.calc(calculatedStats);\n  }, predefinedStats);\n  /*\n  for (let key of noShow) {\n    delete stats[key];\n  }\n   */\n\n  return stats;\n};\n\nmodule.exports.compute = function (stat, args) {\n  stat_def = definitions.find(function (s) {\n    return s.name === stat;\n  });\n\n  if (stat_def == null) {\n    throw new ReferenceError('Cannot find statistic \\'' + stat + '\\'');\n  }\n\n  return stat_def.calc(args)[stat];\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/index.js\n// module id = 121\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/index.js?")},139:/*!************************************************!*\
  !*** ./engine/regression/svd-golub-reinsch.js ***!
  \************************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){"use strict";eval("\n\nvar Matrix = __webpack_require__(/*! ../matrix */ 79);\n\nfunction pythag(a, b) {\n  var absa = Math.abs(a),\n      absb = Math.abs(b);\n  return absa > absb ? absa * Math.sqrt(1 + Math.pow(absb / absa, 2)) : absb === 0 ? 0 : absb * Math.sqrt(1 + Math.pow(absa / absb, 2));\n}\n/**\n * Translation of the SVD algorithm published in Numer. Math. 14, 403-420 (1970)\n * by G. H. Golub and C. Reinsch.\n *\n * Source: http://cs.brown.edu/courses/csci0530/current/homeworks/svd.py\n *\n * @param {Matrix<m,n>} A Matrix to decompose (m >= n)\n * @return {[Matrix<m,m>, Matrix<m,n>, Matrix<n,n>]} [U, E, V] s.t. A = U*E*V\n */\n\n\nfunction svd(A) {\n  var eps = Number.EPSILON,\n      tol = Number.MIN_VALUE / eps;\n\n  if (1.0 + eps <= 1.0) {\n    throw new Error('Make eps bigger');\n  }\n\n  if (tol <= 0.0) {\n    throw new Error('Make tol bigger');\n  }\n\n  var itmax = 50,\n      u = A.clone(),\n      m = u.shape[0],\n      n = u.shape[1],\n      e = [],\n      q = [],\n      v = new Matrix(n, n),\n      g = 0.0,\n      x = 0.0,\n      i,\n      j,\n      k,\n      l,\n      s,\n      f,\n      h,\n      y,\n      iteration,\n      gotoTestFConvergence,\n      z,\n      c,\n      l1;\n\n  if (m < n) {\n    throw new Error('m is less than n');\n  }\n\n  for (i = 0; i < n; i++) {\n    e[i] = g;\n    s = 0.0;\n    l = i + 1;\n\n    for (j = i; j < m; j++) {\n      s += u.data[j * n + i] * u.data[j * n + i];\n    }\n\n    if (s < tol) {\n      g = 0.0;\n    } else {\n      f = u.data[i * n + i];\n\n      if (f < 0.0) {\n        g = Math.sqrt(s);\n      } else {\n        g = -Math.sqrt(s);\n      }\n\n      h = f * g - s;\n      u.data[i * n + i] = f - g;\n\n      for (j = l; j < n; j++) {\n        s = 0.0;\n\n        for (k = i; k < m; k++) {\n          s += u.data[k * n + i] * u.data[k * n + j];\n        }\n\n        f = s / h;\n\n        for (k = i; k < m; k++) {\n          u.data[k * n + j] = u.data[k * n + j] + f * u.data[k * n + i];\n        }\n      }\n    }\n\n    q[i] = g;\n    s = 0.0;\n\n    for (j = l; j < n; j++) {\n      s = s + u.data[i * n + j] * u.data[i * n + j];\n    }\n\n    if (s <= tol) {\n      g = 0.0;\n    } else {\n      f = u.data[i * n + i + 1];\n\n      if (f < 0.0) {\n        g = Math.sqrt(s);\n      } else {\n        g = -Math.sqrt(s);\n      }\n\n      h = f * g - s;\n      u.data[i * n + i + 1] = f - g;\n\n      for (j = l; j < n; j++) {\n        e[j] = u.data[i * n + j] / h;\n      }\n\n      for (j = l; j < m; j++) {\n        s = 0.0;\n\n        for (k = l; k < n; k++) {\n          s = s + u.data[j * n + k] * u.data[i * n + k];\n        }\n\n        for (k = l; k < n; k++) {\n          u.data[j * n + k] = u.data[j * n + k] + s * e[k];\n        }\n      }\n    }\n\n    y = Math.abs(q[i]) + Math.abs(e[i]);\n\n    if (y > x) {\n      x = y;\n    }\n  } // accumulation of right hand transformations\n\n\n  for (i = n - 1; i > -1; i--) {\n    if (g !== 0) {\n      h = g * u.data[i * n + i + 1];\n\n      for (j = l; j < n; j++) {\n        v.data[j * n + i] = u.data[i * n + j] / h;\n      }\n\n      for (j = l; j < n; j++) {\n        s = 0.0;\n\n        for (k = l; k < n; k++) {\n          s += u.data[i * n + k] * v.data[k * n + j];\n        }\n\n        for (k = l; k < n; k++) {\n          v.data[k * n + j] += s * v.data[k * n + i];\n        }\n      }\n    }\n\n    for (j = l; j < n; j++) {\n      v.data[i * n + j] = 0.0;\n      v.data[j * n + i] = 0.0;\n    }\n\n    v.data[i * n + i] = 1.0;\n    g = e[i];\n    l = i;\n  } // accumulation of left hand transformations\n\n\n  for (i = n - 1; i > -1; i--) {\n    l = i + 1;\n    g = q[i];\n\n    for (j = l; j < n; j++) {\n      u.data[i * n + j] = 0.0;\n    }\n\n    if (g !== 0.0) {\n      h = u.data[i * n + i] * g;\n\n      for (j = l; j < n; j++) {\n        s = 0.0;\n\n        for (k = l; k < m; k++) {\n          s += u.data[k * n + i] * u.data[k * n + j];\n        }\n\n        f = s / h;\n\n        for (k = i; k < m; k++) {\n          u.data[k * n + j] += f * u.data[k * n + i];\n        }\n      }\n\n      for (j = i; j < m; j++) {\n        u.data[j * n + i] = u.data[j * n + i] / g;\n      }\n    } else {\n      for (j = i; j < m; j++) {\n        u.data[j * n + i] = 0.0;\n      }\n    }\n\n    u.data[i * n + i] += 1.0;\n  } // diagonalization of the bidiagonal form\n\n\n  eps = eps * x;\n\n  for (k = n - 1; k > -1; k--) {\n    for (iteration = 0; iteration < itmax; iteration++) {\n      // test f splitting\n      for (l = k; l > -1; l--) {\n        gotoTestFConvergence = false;\n\n        if (Math.abs(e[l]) <= eps) {\n          // goto test f convergence\n          gotoTestFConvergence = true;\n          break;\n        }\n\n        if (Math.abs(q[l - 1]) <= eps) {\n          // goto cancellation\n          break;\n        }\n      }\n\n      if (!gotoTestFConvergence) {\n        // cancellation of e[l] if l>0\n        c = 0.0;\n        s = 1.0;\n        l1 = l - 1;\n\n        for (i = l; i < k + 1; i++) {\n          f = s * e[i];\n          e[i] = c * e[i];\n\n          if (Math.abs(f) <= eps) {\n            // goto test f convergence\n            break;\n          }\n\n          g = q[i];\n          h = pythag(f, g);\n          q[i] = h;\n          c = g / h;\n          s = -f / h;\n\n          for (j = 0; j < m; j++) {\n            y = u.data[j * n + l1];\n            z = u.data[j * n + i];\n            u.data[j * n + l1] = y * c + z * s;\n            u.data[j * n + i] = -y * s + z * c;\n          }\n        }\n      } // test f convergence\n\n\n      z = q[k];\n\n      if (l === k) {\n        // convergence\n        if (z < 0.0) {\n          // q[k] is made non-negative\n          q[k] = -z;\n\n          for (j = 0; j < n; j++) {\n            v.data[j * n + k] = -v.data[j * n + k];\n          }\n        }\n\n        break; // break out of iteration loop and move on to next k value\n      }\n\n      if (iteration >= itmax - 1) {\n        throw new Error('SVD: No convergence');\n      } // shift from bottom 2x2 minor\n\n\n      x = q[l];\n      y = q[k - 1];\n      g = e[k - 1];\n      h = e[k];\n      f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);\n      g = pythag(f, 1.0);\n\n      if (f < 0) {\n        f = ((x - z) * (x + z) + h * (y / (f - g) - h)) / x;\n      } else {\n        f = ((x - z) * (x + z) + h * (y / (f + g) - h)) / x;\n      } // next QR transformation\n\n\n      c = 1.0;\n      s = 1.0;\n\n      for (i = l + 1; i < k + 1; i++) {\n        g = e[i];\n        y = q[i];\n        h = s * g;\n        g = c * g;\n        z = pythag(f, h);\n        e[i - 1] = z;\n        c = f / z;\n        s = h / z;\n        f = x * c + g * s;\n        g = -x * s + g * c;\n        h = y * s;\n        y = y * c;\n\n        for (j = 0; j < n; j++) {\n          x = v.data[j * n + i - 1];\n          z = v.data[j * n + i];\n          v.data[j * n + i - 1] = x * c + z * s;\n          v.data[j * n + i] = -x * s + z * c;\n        }\n\n        z = pythag(f, h);\n        q[i - 1] = z;\n        c = f / z;\n        s = h / z;\n        f = c * g + s * y;\n        x = -s * g + c * y;\n\n        for (j = 0; j < m; j++) {\n          y = u.data[j * n + i - 1];\n          z = u.data[j * n + i];\n          u.data[j * n + i - 1] = y * c + z * s;\n          u.data[j * n + i] = -y * s + z * c;\n        }\n      }\n\n      e[l] = 0.0;\n      e[k] = f;\n      q[k] = x; // goto test f splitting\n    }\n  }\n\n  return [u, q, v];\n}\n\nmodule.exports = svd;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/regression/svd-golub-reinsch.js\n// module id = 139\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/regression/svd-golub-reinsch.js?")},140:/*!****************************************!*\
  !*** ./engine/statistics/Statistic.js ***!
  \****************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports){eval('function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar defaults = [\'X\', \'y\', \'BHat\'];\n\nvar Statistic = /*#__PURE__*/function () {\n  function Statistic(name, args, fn, description) {\n    _classCallCheck(this, Statistic);\n\n    this.name = name;\n    this.args = args;\n    this.fn = fn;\n  }\n\n  _createClass(Statistic, [{\n    key: "calc",\n    value: function calc(statistics) {\n      statistics[this.name] = this.fn(statistics);\n      return statistics;\n    }\n  }, {\n    key: "inspect",\n    value: function inspect(depth) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        stylize: function stylize(x) {\n          return \'\' + x;\n        }\n      };\n      return "".concat(this.name, "(").concat(this.args, ")");\n    }\n  }]);\n\n  return Statistic;\n}();\n\nmodule.exports = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return _construct(Statistic, args);\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/Statistic.js\n// module id = 140\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/Statistic.js?')},141:/*!*************************************************!*\
  !*** ./engine/statistics/distributions-socr.js ***!
  \*************************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction statcom(q, i, j, b) {\n  var zz = 1,\n      z = zz,\n      k = i;\n\n  while (k <= j) {\n    zz *= q * k / (k - b);\n    z += zz;\n    k += 2;\n  }\n\n  return z;\n}\n/**\n * Two sided T-distribution estimator.\n *\n * Source: https://github.com/SOCR/HTML5_WebSite\n *         (Applets/Normal_T_Chi2_F_Tables.html)\n * License: GNU LGPL\n *\n * @param {Number} t T-statistic for some independent variable\n * @param {Number} n Degrees of freedom\n * @return {Number} 2-tailed p-value for the t statistic ( Pr(t) )\n */\n\n\nfunction pt(t, n) {\n  t = Math.abs(t);\n  var w = t / Math.sqrt(n),\n      th = Math.atan(w);\n\n  if (n === 1) {\n    return 1 - th / (Math.PI / 2);\n  }\n\n  var sth = Math.sin(th),\n      cth = Math.cos(th);\n\n  if (n % 2 === 1) {\n    return 1 - (th + sth * cth * statcom(cth * cth, 2, n - 3, -1)) / (Math.PI / 2);\n  }\n\n  return 1 - sth * statcom(cth * cth, 1, n - 3, -1);\n}\n/**\n * Fisher's F-density estimator.\n *\n * Source: https://github.com/SOCR/HTML5_WebSite\n *         (Applets/Normal_T_Chi2_F_Tables.html)\n * License: GNU LGPL\n *\n * @param {Number} f  F value for the model\n * @param {Number} n1 # of terms in the model\n * @param {Number} n2 Degrees of freedom\n * @return {Number} Probability of (F < f)\n */\n\n\nfunction pf(f, n1, n2) {\n  var x = n2 / (n1 * f + n2);\n\n  if (n1 % 2 === 0) {\n    return statcom(1 - x, n2, n1 + n2 - 4, n2 - 2) * Math.pow(x, n2 / 2);\n  }\n\n  if (n2 % 2 === 0) {\n    return 1 - statcom(x, n1, n1 + n2 - 4, n1 - 2) * Math.pow(1 - x, n1 / 2);\n  }\n\n  var th = Math.atan(Math.sqrt(n1 * f / n2)),\n      a = th / (Math.PI / 2),\n      sth = Math.sin(th),\n      cth = Math.cos(th);\n\n  if (n2 > 1) {\n    a += sth * cth * statcom(cth * cth, 2, n2 - 3, -1) / (Math.PI / 2);\n  }\n\n  if (n1 === 1) {\n    return 1 - a;\n  }\n\n  var c = 4 * statcom(sth * sth, n2 + 1, n1 + n2 - 4, n2 - 2) * sth * Math.pow(cth, n2) / Math.PI;\n\n  if (n2 === 1) {\n    return 1 - a + c / 2;\n  }\n\n  var k = 2;\n\n  while (k <= (n2 - 1) / 2) {\n    c *= k / (k - 0.5);\n    k += 1;\n  }\n\n  return 1 - a + c;\n}\n\nmodule.exports.pt = pt;\nmodule.exports.pf = pf;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/distributions-socr.js\n// module id = 141\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/distributions-socr.js?")},168:/*!*****************************************!*\
  !*** ./engine/statistics/metadata.json ***!
  \*****************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports){eval('module.exports = [{"id":"X","show":false},{"id":"y","show":false},{"id":"v","show":false},{"id":"w","show":false},{"id":"VdivwSq","show":false},{"id":"BHat","show":false},{"id":"yHat","show":false},{"id":"Vary","show":false},{"id":"nd","globalOnly":true,"format":"int","description":"Number of data (rows) in the corresponding Data Table (Fit, Cross or Validate)"},{"id":"np","globalOnly":true,"format":"int","description":"Number of parameters (or terms) in the Current Model"},{"id":"SSE","sort":">","description":"Sum of squares of the residual errors"},{"id":"TSS","globalOnly":true,"description":"Total sum of squares"},{"id":"SSR","description":"Sum of squares due to regression"},{"id":"MSE","description":"Mean square error (variance of the residual errors)"},{"id":"PLACEHOLDER"},{"id":"Rsq","sort":"<","description":"Square of the multiple correlation coefficient"},{"id":"adjRsq","sort":"<","description":"Adjusted R-squared - similar to Rsq, but penalizes for model complexity"},{"id":"PLACEHOLDER"},{"id":"MaxAbsErr","displayName":"Max|Err|","sort":">","description":"Maximum of the absolute value of the residual errors"},{"id":"RMSE","sort":">","description":"Square root of the mean square error"},{"id":"SKEW","sort":"<","description":"Skewness"},{"id":"XKURT","sort":"<","description":"Excess kurtosis"},{"id":"PLACEHOLDER"},{"id":"AIC","sort":">","description":"Akaike Information Criterion"},{"id":"BIC","sort":">","description":"Bayesian Information Criterion"},{"id":"F","sort":"<","description":"F-statistic"},{"id":"pF","displayName":"p(F)","sort":">","description":"Probability that a larger value of the F-statistic occurs by chance. This is a test of overall model fitness."},{"id":"PLACEHOLDER"},{"id":"seSKEW","displayName":"s.e. SKEW","sort":"<","description":"Estimated standard error of the skewness. If SKEW > 2*s.e.SKEW, there is evidence that residual errors are not normally distributed."},{"id":"seXKURT","displayName":"s.e. XKURT","sort":"<","description":"Estimated standard error of the kurtosis. If |ExKurt|> 2*s.e.ExKurt, there is evidence that residual errors are not normally distributed."},{"id":"t","sort":"|<|","candidateOnly":true,"default":true,"description":"The t-statistic used to determine how significant this term is. A value above about 2.0 is usually considered significant."},{"id":"pt","displayName":"p(t)","sort":">","candidateOnly":true,"default":true,"description":"The probability that this term occurs by chance. Cell is colored green if p(t) > alpha (default alpha = 0.05)."},{"id":"stdev","show":false},{"id":"mean","show":false},{"id":"weights","show":false},{"id":"log","show":false},{"id":"mean","show":false},{"id":"std","show":false},{"id":"standardize","show":false},{"id":"RMS","show":false},{"id":"rescale","show":false},{"id":"k_order_difference","show":false}]\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/metadata.json\n// module id = 168\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/metadata.json?')},169:/*!************************************!*\
  !*** ./engine/regression/index.js ***!
  \************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){eval("// lstsqSVD | lstsqNE\nvar METHOD = 'lstsqSVD';\nmodule.exports.svd = __webpack_require__(/*! ./svd-golub-reinsch */ 139);\nmodule.exports.lstsq = __webpack_require__(/*! ./lstsq */ 205)[METHOD];\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/regression/index.js\n// module id = 169\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/regression/index.js?")},204:/*!*********************************!*\
  !*** ./engine/matrix/Matrix.js ***!
  \*********************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar utils = __webpack_require__(/*! ../utils */ 78);\n/**\n * Private members\n *\n * @private\n */\n\n\nvar _data = Symbol('data');\n\nvar _m = Symbol('m');\n\nvar _n = Symbol('n'); // Maximum number of decimal points to print\n\n\nvar PRINT_DECIMALS = 5; // Number.MAX_SAFE_INTEGER value [ i.e. doesn't support :( ]\n\nvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n/**\n * Swap rows `i` and `j` in matrix `m` in place.\n *\n * @param {Matrix} m\n * @param {number} i\n * @param {number} j\n */\n\nfunction swapRows(m, i, j) {\n  var k, temp;\n\n  for (k = 0; k < m[_n]; k += 1) {\n    temp = m[_data][j * m[_n] + k];\n    m[_data][j * m[_n] + k] = m[_data][i * m[_n] + k];\n    m[_data][i * m[_n] + k] = temp;\n  }\n}\n/**\n * Divide row `i` in both matrix `m` and matrix `inv` by `factor`.\n *\n * @param {Matrix} m\n * @param {Matrix} inv\n * @param {number} i\n * @param {number} j\n */\n\n\nfunction divideRow(m, inv, i, factor) {\n  var k, temp;\n\n  for (k = 0; k < m[_n]; k += 1) {\n    m[_data][i * m[_n] + k] /= factor;\n    inv[_data][i * m[_n] + k] /= factor;\n  }\n}\n/**\n * Subtract multiple of row `i` and column `j` from every row in `m` and `inv`.\n *\n * @param {Matrix} m\n * @param {Matrix} inv\n * @param {number} i\n * @param {number} j\n */\n\n\nfunction subtractRowMultiple(m, inv, i, j) {\n  var k, l, factor;\n\n  for (l = 0; l < m[_m]; l += 1) {\n    factor = m[_data][l * m[_n] + j];\n\n    if (l !== i) {\n      for (k = 0; k < m[_n]; k += 1) {\n        m[_data][l * m[_n] + k] -= m[_data][i * m[_n] + k] * factor;\n        inv[_data][l * m[_n] + k] -= inv[_data][i * m[_n] + k] * factor;\n      }\n    }\n  }\n}\n/**\n * A speedy 2-dimensional matrix implementation.\n *\n * @class Matrix\n */\n\n\nvar Matrix = /*#__PURE__*/function () {\n  /**\n   * Creates a new Matrix of size <n, m>, using `stuff`.\n   *\n   * If `stuff` is a Float64Array, then the reference will be used. Otherwise,\n   * its contents will be copied into a new Float64Array.\n   *\n   * @param {number | number[][]}       n     Number of columns (or nested arrays\n   *                                          that look like a matrix)\n   * @param {number}                    m     Number of rows\n   * @param {Float64Array | number[][]} stuff Items to populate the matrix\n   */\n  function Matrix(m, n, stuff) {\n    var skip_NaN = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    _classCallCheck(this, Matrix);\n\n    if (m instanceof Matrix) {\n      return m;\n    }\n\n    if (Array.isArray(m)) {\n      return Matrix.from(m);\n    }\n\n    if (stuff != null) {\n      stuff = stuff instanceof Float64Array ? stuff : Float64Array.from(stuff);\n\n      if (stuff.length !== m * n) {\n        throw new Error('Array does not match the specified dimensions');\n      }\n    } else {\n      stuff = new Float64Array(m * n);\n    } // Filter Out NaN Columns\n\n\n    var valid_columns = new Array(n).fill(true);\n    var valid_column_count = n; //i: Iterate over columns\n\n    for (var i = 0; i < n; i++) {\n      // j: iterate over rows\n      for (var j = 0; j < m; j++) {\n        if (!skip_NaN && isNaN(stuff[j * n + i])) {\n          valid_columns[i] = false;\n          valid_column_count -= 1;\n          break;\n        }\n      }\n    } // If NaN Column Found, create new Float64 Array & Populate\n\n\n    if (valid_column_count != n) {\n      var new_stuff = new Float64Array(valid_column_count * m);\n      var iterator = 0;\n\n      for (var _i = 0; _i < m * n; _i++) {\n        var curr_col = _i % n;\n\n        if (valid_columns[curr_col]) {\n          new_stuff[iterator++] = stuff[_i];\n        }\n      }\n\n      stuff = new_stuff;\n      n = valid_column_count;\n    }\n\n    this[_data] = stuff;\n    this[_m] = m;\n    this[_n] = n;\n    return this;\n  }\n  /**\n   * Retrieve the element at the ith row and jth column.\n   *\n   * @param {number} i s.t. 0 <= i < m\n   * @param {number} j s.t. 0 <= i < n\n   * @return {number} Element at (i, j)\n   */\n\n\n  _createClass(Matrix, [{\n    key: \"get\",\n    value: function get(i, j) {\n      return this[_data][i * this[_n] + j];\n    }\n    /**\n     * Set the element at the ith row and jth column.\n     *\n     * @param {number} i s.t. 0 <= i < m\n     * @param {number} j s.t. 0 <= i < n\n     * @param {number} value To replace the existing one\n     * @return {number} Element at (i, j)\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(i, j, value) {\n      return this[_data][i * this[_n] + j] = value;\n    }\n    /**\n     * Performs element-wise addition between two matrices and returns a new copy.\n     *\n     * @param {number | Matrix<m,n>} other  Scalar or Matrix with equivalent\n     *                                      dimensions to this\n     * @return {Matrix<m,n>} this + other\n     * @throws {Error} If dimensions do not match\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      var sum = this.clone(),\n          i;\n\n      if (typeof other === 'number') {\n        for (i = 0; i < sum[_data].length; i += 1) {\n          sum[_data][i] += other;\n        }\n      } else {\n        if (this[_m] !== other[_m] || this[_n] !== other[_n]) {\n          throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_n] + ' !== ' + other[_m] + ' && ' + this[_m] + ' !== ' + other[_m]);\n        }\n\n        for (i = 0; i < sum[_data].length; i += 1) {\n          sum[_data][i] += other[_data][i];\n        }\n      }\n\n      return sum;\n    }\n    /**\n     * Performs element-wise subtraction between two matrices and returns a new\n     * copy.\n     *\n     * @param {number | Matrix<m,n>} other  Scalar or Matrix with equivalent\n     *                                      dimensions to this\n     * @return {Matrix<m,n>} this - other\n     * @throws {Error} If dimensions do not match\n     */\n\n  }, {\n    key: \"sub\",\n    value: function sub(other) {\n      var sum = this.clone(),\n          i;\n\n      if (typeof other === 'number') {\n        for (i = 0; i < sum[_data].length; i += 1) {\n          sum[_data][i] -= other;\n        }\n      } else {\n        if (this[_m] !== other[_m] || this[_n] !== other[_n]) {\n          throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_n] + ' !== ' + other[_m] + ' && ' + this[_m] + ' !== ' + other[_m]);\n        }\n\n        for (i = 0; i < sum[_data].length; i += 1) {\n          sum[_data][i] -= other[_data][i];\n        }\n      }\n\n      return sum;\n    }\n    /**\n     * Performs matrix multiplication between this and other.\n     *\n     * @param {Matrix<n,k>} other Matrix whose rows must be === to this's columns\n     * @return {Matrix<m,k>} this * other\n     * @throws {Error} If dimensions do not match\n     */\n\n  }, {\n    key: \"dot\",\n    value: function dot(other) {\n      if (this[_n] !== other[_m]) {\n        throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_n] + ' !== ' + other[_m]);\n      }\n\n      var product = new Matrix(this[_m], other[_n]),\n          i,\n          j,\n          k,\n          sum;\n\n      for (i = 0; i < this[_m]; i += 1) {\n        for (j = 0; j < other[_n]; j += 1) {\n          for (k = 0, sum = 0; k < this[_n]; k += 1) {\n            sum += this[_data][i * this[_n] + k] * other[_data][k * other[_n] + j];\n          }\n\n          product[_data][i * other[_n] + j] = sum;\n        }\n      }\n\n      return product;\n    }\n    /**\n     * Computes the inverse of the matrix (only if it is square!).\n     *\n     * @return {Matrix<m,n>} Inverse matrix s.t. this * inv(this) === I\n     * @throws {Error} If not a square matrix\n     */\n\n  }, {\n    key: \"inv\",\n    value: function inv() {\n      if (this[_m] !== this[_n]) {\n        throw new Error('Must be square');\n      }\n\n      var self = this.clone(),\n          inverse = Matrix.eye(this[_m], this[_n]),\n          i,\n          j,\n          k,\n          factor;\n\n      for (i = 0, j = 0; i < self[_m] && j < self[_n]; i += 1, j += 1) {\n        if (self[_data] === 0) {\n          for (k = 0; self[_data][k * self[_n] + j] !== 0 && k < self[_m]; k += 1) {\n            ;\n          }\n\n          if (k >= self[_m]) {\n            j += 1;\n            continue;\n          }\n\n          swapRows(self, j, k);\n          swapRows(inverse, j, k);\n        }\n\n        divideRow(self, inverse, j, self[_data][j * self[_n] + j]);\n        subtractRowMultiple(self, inverse, i, j);\n      }\n\n      return inverse;\n    }\n    /**\n     * Returns a copy of the matrix.\n     *\n     * @return {Matrix<m,n>} Fresh clone\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Matrix(this[_m], this[_n], this[_data].slice());\n    }\n    /**\n     * Horizontally stacks `other` and returns the new matrix.\n     *\n     * @param {Matrix<m,k>} other Matrix whose rows === this's rows\n     * @return {Matrix<m,n+k>} Horizontal concatenation of this and other\n     * @throws {Error} If dimensions do not match\n     */\n\n  }, {\n    key: \"hstack\",\n    value: function hstack(other) {\n      if (this[_m] !== other[_m]) {\n        throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_m] + ' !== ' + other[_m]);\n      }\n\n      var newM = this[_n] + other[_n],\n          stacked = new Matrix(this[_m], newM),\n          i,\n          j;\n\n      for (i = 0; i < this[_m]; i += 1) {\n        for (j = 0; j < this[_n]; j += 1) {\n          stacked[_data][i * newM + j] = this[_data][i * this[_n] + j];\n        }\n\n        for (j = 0; j < other[_n]; j += 1) {\n          stacked[_data][i * newM + this[_n] + j] = other[_data][i * other[_n] + j];\n        }\n      }\n\n      return stacked;\n    }\n    /**\n     * Vertically stacks `other` and returns the new matrix.\n     *\n     * @param {Matrix<k,n>} other Matrix whose cols === this's cols\n     * @return {Matrix<m+k,n>} Vertical concatenation of this and other\n     * @throws {Error} If dimensions do not match\n     */\n\n  }, {\n    key: \"vstack\",\n    value: function vstack(other) {\n      if (this[_n] !== other[_n]) {\n        throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_n] + ' !== ' + other[_n]);\n      }\n\n      var stacked = new Matrix(this[_m] + other[_m], this[_n]);\n\n      stacked[_data].subarray(0, this[_m] * this[_n]).set(this[_data]);\n\n      stacked[_data].subarray(this[_m] * this[_n]).set(other[_data]);\n\n      return stacked;\n    }\n    /**\n     * Performs element-wise exponentiation to the matrix and returns a new copy.\n     *\n     * @param {number} exponent Power to raise each element to\n     * @return {Matrix<m,n>} this[i,i]^exponent\n     */\n\n  }, {\n    key: \"dotPow\",\n    value: function dotPow(exponent) {\n      var powd = this.clone(),\n          i;\n\n      for (i = 0; i < powd[_data].length; i += 1) {\n        powd[_data][i] = Math.pow(powd[_data][i], exponent);\n\n        if (!Number.isFinite(powd[_data][i])) {\n          powd[_data][i] = MAX_SAFE_INTEGER;\n        }\n      }\n\n      return powd;\n    }\n    /**\n     * Performs element-wise multiplication to the matrix and returns a new copy.\n     *\n     * @param {number | Matrix} n Multiplicand to multiply each element by, or a\n     *                            matrix whose elements will be iterated through\n     *                            in alignment with this\n     * @return {Matrix<m,n>} this[i,i] * n   OR   this[i,i] * n[i,i]\n     */\n\n  }, {\n    key: \"dotMultiply\",\n    value: function dotMultiply(n) {\n      var product = this.clone(),\n          i;\n\n      if (typeof n === 'number') {\n        for (i = 0; i < product[_data].length; i += 1) {\n          product[_data][i] = product[_data][i] * n;\n        }\n      } else if (n instanceof Matrix) {\n        for (i = 0; i < product[_data].length; i += 1) {\n          product[_data][i] = product[_data][i] * n[_data][i];\n        }\n      }\n\n      return product;\n    }\n    /**\n     * Performs element-wise division to the matrix and returns a new copy.\n     *\n     * @param {number | Matrix} n Divisor to divide each element by, or a matrix\n     *                            whose elements will be iterated through in\n     *                            alignment with this\n     * @return {Matrix<m,n>} this[i,i] / n   OR   this[i,i] / n[i,i]\n     */\n\n  }, {\n    key: \"dotDivide\",\n    value: function dotDivide(n) {\n      var product = this.clone(),\n          i,\n          j;\n\n      if (typeof n === 'number') {\n        for (i = 0; i < product[_data].length; i += 1) {\n          product[_data][i] = product[_data][i] / n;\n        }\n      } else if (n instanceof Matrix) {\n        for (i = 0, j = 0; i < product[_data].length; i += 1, j += 1) {\n          if (j >= n[_data].length) {\n            j = 0;\n          }\n\n          product[_data][i] = product[_data][i] / n[_data][j];\n        }\n      }\n\n      return product;\n    }\n  }, {\n    key: \"log\",\n    value: function log() {\n      var product = this.clone(),\n          i;\n\n      for (i = 0; i < product[_data].length; i += 1) {\n        product[_data][i] = Math.log10(product[_data][i]);\n      }\n\n      return product;\n    }\n  }, {\n    key: \"appendM\",\n    value: function appendM(m) {\n      var matrix_dim = m.shape,\n          rows = this[_m],\n          cols = this[_n] + matrix_dim[1],\n          append_matrix = new Matrix(rows, cols),\n          i,\n          j;\n\n      for (i = 0; i < rows; i += 1) {\n        for (j = 0; j < cols; j += 1) {\n          var use_m = j - this[_n];\n          var data_pt = use_m >= 0 ? m[_data][i * matrix_dim[1] + use_m] : this[_data][i * this[_n] + j];\n          append_matrix[_data][i * cols + j] = data_pt;\n        }\n      }\n\n      return append_matrix;\n    }\n    /**\n     * @see inspect\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.inspect();\n    }\n    /**\n     * Converts to nested array format\n     *\n     * @return {[][]} Nested arrays, where each child array is a row\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var i, rows;\n\n      for (i = 1, rows = []; i <= this[_m]; i += 1) {\n        rows.push(Array.from(this[_data].slice((i - 1) * this[_n], i * this[_n])));\n      }\n\n      return rows;\n    }\n    /**\n     * Stringifies the matrix into a pretty format\n     *\n     * @return {string} Representation of the matrix\n     */\n\n  }, {\n    key: \"inspect\",\n    value: function inspect(depth) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        stylize: function stylize(x) {\n          return '' + x;\n        }\n      };\n      var repr = options.stylize(this.constructor.name, 'none'),\n          strings = Array.from(this[_data]).map(function (i) {\n        return ('' + i).match(/(NaN|-?Infinity|-?\\d*)\\.?(\\d*)/);\n      }),\n          lwidth = Math.max.apply(null, strings.map(function (match) {\n        return match[1].length;\n      })),\n          rwidth = Math.min(Math.max.apply(null, strings.map(function (match) {\n        return match[2].length;\n      })), PRINT_DECIMALS),\n          rows = [],\n          i;\n      strings = Array.from(this[_data]).map(function (n) {\n        return options.stylize(utils.formatNum(lwidth, rwidth, n), 'number');\n      });\n\n      for (i = 0; i < this[_m]; i += 1) {\n        rows.push('[ ' + strings.slice(i * this[_n], (i + 1) * this[_n]).join(', ') + ' ]');\n      }\n\n      return repr + ' ' + utils.padAll(this.constructor.name.length + 1, rows.join('\\n')).trim();\n    }\n    /**\n     * Retrieves/sets the ith column of the matrix\n     *\n     * @param {number}    i         Column index\n     * @param {number[]}  [newCol]  Elements to replace the col with\n     * @return {Matrix<m,1>} Column as a matrix\n     */\n\n  }, {\n    key: \"col\",\n    value: function col(i, newCol) {\n      var theCol = new Matrix(this[_m], 1),\n          k;\n\n      if (newCol != null) {\n        if (newCol.length > this[_m]) {\n          throw new RangeError('newCol cannot be longer than ' + this[_m]);\n        }\n\n        for (k = 0; k < this[_m]; k += 1) {\n          this[_data][k * this[_n] + i] = newCol[k];\n        }\n      }\n\n      for (k = 0; k < this[_m]; k += 1) {\n        theCol[_data][k] = this[_data][k * this[_n] + i];\n      }\n\n      return theCol;\n    }\n    /**\n     * Retrieves/sets the ith row of the matrix\n     *\n     * @param {number}    i         Row index\n     * @param {number[]}  [newRow]  Elements to replace the row with\n     * @return {Matrix<1,n>} Row as a matrix\n     */\n\n  }, {\n    key: \"row\",\n    value: function row(i, newRow) {\n      if (newRow != null) {\n        if (newRow.length > this[_n]) {\n          throw new RangeError('newRow cannot be longer than ' + this[_n]);\n        }\n\n        this[_data].subarray(i * this[_n]).set(newRow);\n      }\n\n      return new Matrix(1, this[_n], this[_data].slice(i * this[_n], (i + 1) * this[_n]));\n    }\n    /**\n     * Retrieves a subset of the matrix, constructed from indices in `rows` and\n     * `cols`. The resulting matrix will have rows s.t. result[i] = this[rows[i]]\n     * and columns s.t. result[i][j] = this[rows[i][cols[j]]]\n     *\n     * @param {number[]} rows Array of indices used to construct the subset\n     * @param {number[]} cols Array of indices used to construct the subset\n     * @return {Matrix<rows.length, cols.length>} Subset of this\n     */\n\n  }, {\n    key: \"subset\",\n    value: function subset() {\n      var rows = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ':';\n      var cols = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ':';\n      rows = utils.convertRange(rows, this[_m]);\n      cols = utils.convertRange(cols, this[_n]);\n      var subMatrix = new Matrix(rows.length, cols.length),\n          i,\n          j;\n\n      for (i = 0; i < rows.length; i += 1) {\n        for (j = 0; j < cols.length; j += 1) {\n          subMatrix[_data][i * subMatrix[_n] + j] = this[_data][rows[i] * this[_n] + cols[j]];\n        }\n      }\n\n      return subMatrix;\n    } // Create subset of data with row-end\n\n  }, {\n    key: \"lo\",\n    value: function lo() {\n      var row = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return new Matrix(this[_m] - row, this[_n], this[_data].slice(row * this[_n]));\n    } // Create a subset of data withs rows 0-row\n\n  }, {\n    key: \"hi\",\n    value: function hi() {\n      var row = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return new Matrix(row, this[_n], this[_data].slice(0, row * this[_n]));\n    } // Function removes column from matrix\n\n  }, {\n    key: \"delColumn\",\n    value: function delColumn() {\n      var col = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var columns = this[_n];\n      return new Matrix(this[_m], this[_n] - 1, this[_data].filter(function (_, i) {\n        return i % columns !== col;\n      }));\n    } // TODO: document\n\n  }, {\n    key: \"shift\",\n    value: function shift(rows) {\n      var newData = new Float64Array(this[_m] * this[_n]);\n      newData.subarray(this[_n] * rows).set(this[_data].subarray(0, -(this[_n] * rows) || this[_data].length));\n      return new Matrix(this[_n], this[_m], newData);\n    }\n    /**\n     * Retrieves the diagonal elements as a 1 x min(m, n) matrix.\n     *\n     * @return {Matrix<1,min(m,n)>} Diagonal elements\n     */\n\n  }, {\n    key: \"diag\",\n    value: function diag() {\n      var diagonal = new Matrix(1, Math.min(this[_m], this[_n])),\n          i;\n\n      for (i = 0; i < this[_m] && i < this[_n]; i += 1) {\n        diagonal[_data][i] = this[_data][i * this[_n] + i];\n      }\n\n      return diagonal;\n    }\n    /**\n     * Performs `Math.abs()` on each element then returns the resulting matrix.\n     *\n     * @return {Matrix<m,n>} A clone of `this`, but with the absolute value of\n     *                       each element\n     */\n\n  }, {\n    key: \"abs\",\n    value: function abs() {\n      var absolute = this.clone(),\n          i;\n\n      for (i = 0; i < absolute[_data].length; i += 1) {\n        absolute[_data][i] = Math.abs(absolute[_data][i]);\n      }\n\n      return absolute;\n    }\n    /**\n     * Sums all of the elements.\n     *\n     * @return {number} Sum of all of the elements\n     */\n\n  }, {\n    key: \"sum\",\n    value: function sum() {\n      var tot = 0,\n          i;\n\n      for (i = 0; i < this[_data].length; i += 1) {\n        tot += this[_data][i];\n      }\n\n      return tot;\n    }\n    /**\n     * Takes the product of all elements.\n     *\n     * @return {number} Product of all elements\n     */\n\n  }, {\n    key: \"prod\",\n    value: function prod() {\n      var tot = 1,\n          i;\n\n      for (i = 0; i < this[_data].length; i += 1) {\n        tot *= this[_data][i];\n      }\n\n      return tot;\n    }\n    /**\n     * Get minimum value in matrix\n     *\n     * @return {number} Minimum value\n     */\n\n  }, {\n    key: \"min\",\n    value: function min() {\n      var i, min;\n\n      for (i = 0, min = Infinity; i < this[_data].length; i += 1) {\n        min = Math.min(min, this[_data][i]);\n      }\n\n      return min;\n    }\n    /**\n     * Get maximum value in matrix\n     *\n     * @return {number} Maximum value\n     */\n\n  }, {\n    key: \"max\",\n    value: function max() {\n      var i, max;\n\n      for (i = 0, max = -Infinity; i < this[_data].length; i += 1) {\n        max = Math.max(max, this[_data][i]);\n      }\n\n      return max;\n    }\n    /**\n     * @property {Matrix<n,m>} T The transposition of the matrix\n     */\n\n  }, {\n    key: \"T\",\n    get: function get() {\n      var transpose = new Matrix(this[_n], this[_m]),\n          i,\n          j;\n\n      for (i = 0; i < this[_m]; i += 1) {\n        for (j = 0; j < this[_n]; j += 1) {\n          transpose[_data][j * this[_m] + i] = this[_data][i * this[_n] + j];\n        }\n      }\n\n      return transpose;\n    }\n    /**\n     * @property {[number, number]} shape The shape of this matrix [m, n]\n     */\n\n  }, {\n    key: \"shape\",\n    get: function get() {\n      return [this[_m], this[_n]];\n    }\n    /**\n     * @property {Float64Array} data The underlying storage for the matrix\n     */\n\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this[_data];\n    }\n    /**\n     * Generates a matrix full of random (0, 1) numbers.\n     *\n     * @static\n     * @return {Matrix<m,n>} Matrix full'a random numbas\n     */\n\n  }], [{\n    key: \"random\",\n    value: function random(m, n) {\n      var randMatrix = new Matrix(m, n),\n          i,\n          j;\n\n      for (i = 0; i < m; i += 1) {\n        for (j = 0; j < n; j += 1) {\n          randMatrix[_data][i * n + j] = Math.random();\n        }\n      }\n\n      return randMatrix;\n    }\n    /**\n     * Generates a matrix whose diagonal elements equal 1.\n     *\n     * @static\n     * @return {Matrix<m,n>} Diagonal onez\n     */\n\n  }, {\n    key: \"eye\",\n    value: function eye(m) {\n      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : m;\n      var onez = new Matrix(m, n),\n          i,\n          j;\n\n      for (i = 0; i < m; i += 1) {\n        onez[_data][i * n + i] = 1;\n      }\n\n      return onez;\n    }\n    /**\n     * Creates a matrix from matrix-looking nested arrays, or a flat array and the\n     * given `m` and `n`.\n     *\n     * @param {iterable | Matrix} arr Values to populate the matrix with\n     * @param {number}            m   Rows in the new matrix\n     * @param {number}            n   Columns in the new matrix\n     */\n\n  }, {\n    key: \"from\",\n    value: function from(arr, m, n) {\n      if (arr instanceof Matrix) {\n        return arr.clone();\n      }\n\n      if (!Array.isArray(arr)) {\n        throw new TypeError('Expected an array or Matrix');\n      }\n\n      if (arr.length <= 0) {\n        return new Matrix(0, 0);\n      }\n\n      var i;\n      m = m || arr.length;\n      n = n || arr[0].length; // handed a 1-d array\n\n      if (arr[0].length == null) {\n        return new Matrix(1, arr.length, Float64Array.from(arr));\n      } // otherwise, it's a 2-d array (and hopefully not >2-d)\n\n\n      for (i = 0; i < arr.length; i += 1) {\n        if (arr[i].length !== n) {\n          throw new Error('All rows must have equal length');\n        }\n      }\n\n      return new Matrix(m, n, Float64Array.from(utils.join(arr)));\n    }\n    /**\n     * Creates a matrix using `arr` to fill the diagonal elements in order.\n     *\n     * @param {number[m]} arr Array of numbers\n     * @returns {Matrix<m,m>} Matrix consisting only of the diagonal elements\n     */\n\n  }, {\n    key: \"diag\",\n    value: function diag(arr) {\n      var m = arr.length,\n          mat = new Matrix(m, m),\n          i;\n\n      for (i = 0; i < m; i += 1) {\n        mat.data[i * m + i] = arr[i];\n      }\n\n      return mat;\n    }\n  }, {\n    key: \"zeros\",\n    value: function zeros(m) {\n      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : m;\n      return this.eye(m, n).dotMultiply(0);\n    }\n  }]);\n\n  return Matrix;\n}();\n\nmodule.exports = Matrix;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/matrix/Matrix.js\n// module id = 204\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/matrix/Matrix.js?")},205:/*!************************************!*\
  !*** ./engine/regression/lstsq.js ***!
  \************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){"use strict";eval("\n\nvar Matrix = __webpack_require__(/*! ../matrix */ 79);\n\nvar svd = __webpack_require__(/*! ./svd-golub-reinsch */ 139);\n\nvar statistics = __webpack_require__(/*! ../statistics */ 121);\n\nvar dist = __webpack_require__(/*! ../statistics/distributions-socr */ 141);\n\nvar utils = __webpack_require__(/*! ../utils */ 78);\n/**\n * Computes total least squares regression on the matrix `A`, already decomposed\n * using SVD into the constituent `U`, `S` (sigma), and `V` matrices.\n *\n * @param {Matrix<m,n>} A Data matrix\n * @param {Matrix<m,m>} U U matrix resulting from SVD\n * @param {Matrix<m,n>} S Diagonal sigma matrix resulting from SVD\n * @param {Matrix<n,n>} V V matrix resulting from SVD\n * @param {Matrix<m,1>} b Independent column\n * @return {Matrix<n,1>} Estimated weight vector for the parameters (cols) in A\n */\n\n\nfunction lstsqSVD(A, U, S, V, b) {\n  var s = S,\n      m = A.shape[0],\n      n = A.shape[1],\n      eps = Number.EPSILON,\n      efcols = [],\n      maxEig = Math.max.apply(null, s.data),\n      i,\n      d,\n      x;\n\n  for (i = 0; i < n; i++) {\n    if (s.data[i] < Math.max(m, n) * eps * maxEig) {\n      s.data[i] = 0;\n    }\n  }\n\n  d = U.T.dot(b);\n  d = d.dotDivide(s);\n\n  for (i = 0; i < n; i++) {\n    if (Math.abs(d.data[i]) === Infinity) {\n      d.data[i] = 0;\n    }\n  }\n\n  x = V.dot(d);\n  return x;\n}\n/**\n * Compute least squares regression using normal equations, then compute\n * analytical statistics to determine the quality of the fit for the model and\n * for each term in the model.\n *\n *    B'      = inv(X'X)X'y                       <-- weight vector\n *    y'      = XB'\n *\n *    Nd      = # of data\n *    Np      = # of params (coefs) in model\n *\n *    SSE     = sum((y - y')^2)                   ^2 is element-wise\n *    TSS     = sum((y - mean(y))^2)\n *    SSR     = TSS - SSE\n *    Var y   = TSS / (Nd - 1)\n *    MSR     = SSR / (Np - 1)\n *    MSE     = SSE / (Nd - Np)\n *    RSQ     = 1 - (SSE / TSS)\n *    cRSQ    = 1 - R^2\n *    adj-RSQ = 1 - (MSE / Var y)\n *    F       = MSR / MSE\n *    AIC     = log(MSE) + 2*(Np/Nd)\n *    BIC     = log(MSE) + Np*log(Nd)/Nd\n *    t_i     = B' / sqrt( inv(X'X)[i,i] * MSE )   / is element-wise\n *    SKEW    = sum((y-y')^3/N/s^3)\n *    XKURT    = sum((y-y')^4/N/s^4)\n *\n * @return {object} Regression results\n */\n\n\nfunction lstsqNEWithStats(X, y) {\n  var XT = X.T,\n      pseudoInverse = XT.dot(X).inv(),\n      BHat = pseudoInverse.dot(XT).dot(y),\n      yHat = X.dot(BHat) // fit statistics\n  ,\n      nd = X.shape[0],\n      np = X.shape[1],\n      sse = y.sub(yHat).dotPow(2).sum(),\n      tss = y.sub(y.sum() / y.shape[0]).dotPow(2).sum(),\n      ssr = tss - sse,\n      vary = tss / (nd - 1),\n      msr = ssr / (np - 1),\n      mse = sse / (nd - np),\n      rsq = 1 - sse / tss,\n      adjrsq = 1 - mse / vary,\n      f = msr / mse,\n      aic = Math.log10(mse) + 2 * (np / nd),\n      bic = Math.log10(mse) + np * (Math.log10(nd) / nd) // for t-statistics\n  ,\n      rtmse = Math.sqrt(mse),\n      sec = pseudoInverse.diag().abs().dotPow(0.5).dotMultiply(rtmse),\n      tstats = BHat.dotDivide(sec),\n      pts = tstats.clone();\n  pts.data.set(pts.data.map(function (t) {\n    return dist.pt(t, nd - np);\n  }));\n  return {\n    weights: BHat,\n    tstats: tstats,\n    mse: mse,\n    rsq: rsq,\n    adjrsq: adjrsq,\n    f: f,\n    pf: dist.pf(f, np, nd - np),\n    aic: aic,\n    bic: bic,\n    pts: pts\n  };\n}\n\nfunction scale(X) {\n  var stdevs = [];\n  var means = [];\n  var intercept = -1;\n  var i;\n\n  for (i = 0; i < X.shape[1]; i += 1) {\n    var col = X.col(i);\n    var nd = col.shape[0];\n    var mean = col.sum() / nd;\n    var newCol = col.sub(mean);\n    var stdev = Math.sqrt(newCol.dotPow(2).sum() / (nd - 1));\n    means.push(mean);\n\n    if (stdev <= Number.EPSILON && mean === 1) {\n      stdevs.push(1);\n      intercept = i;\n    } else {\n      X.col(i, newCol.dotDivide(stdev).data);\n      stdevs.push(stdev);\n    }\n  }\n\n  return {\n    stdev: new Matrix(stdevs).T,\n    mean: new Matrix(means).T,\n    intercept: intercept\n  };\n}\n/**\n * Compute least squares regression using singular value decomposition, then\n * compute analytical statistics to determine the quality of the fit for the\n * model and for each term in the model.\n *\n *    U, s, V = svd(X)\n *    B'      = V(U'b ./ s)                       See svd.lstsq for more\n *    y'      = XB'\n *\n * @return {object} Regression results\n */\n\n\nfunction lstsqSVDWithStats(X, y, predictors) {\n  var i;\n  var stdev = 1,\n      mean = 0,\n      intercept = -1; //let { stdev, mean, intercept } = scale(X);\n\n  var decomposition = svd(X),\n      U = decomposition[0],\n      w = Matrix.from(decomposition[1]),\n      V = decomposition[2],\n      VdivwSq = V.dotDivide(w).dotPow(2),\n      BHat = predictors || lstsqSVD(X, U, w, V, y),\n      weights = BHat.dotDivide(stdev); // If there is an intercept, un-scale its weight by subtracting the means of\n  // the other columns times the corresponding sign of their weights\n  //\n  //          B_0 = B_0 - sum(mean(i) * sign(weights(i)))\n  //\n\n  if (intercept >= 0) {\n    var interceptWeight = weights.get(0, intercept) + 1;\n\n    for (i = 0; i < weights.shape[0]; i += 1) {\n      interceptWeight -= mean.data[i] * utils.sign(weights.data[i]);\n    }\n\n    weights.data[intercept] = interceptWeight;\n  } // Remove infinitely high values to work around potential divide-by-zero issue\n\n\n  for (i = 0; i < VdivwSq.data.length; i += 1) {\n    if (Math.abs(VdivwSq.data[i]) === Infinity || isNaN(VdivwSq.data[i])) {\n      VdivwSq.data[i] = 0;\n    }\n  }\n\n  return {\n    X: X,\n    y: y,\n    BHat: BHat,\n    VdivwSq: VdivwSq,\n    stdev: stdev,\n    mean: mean,\n    weights: weights,\n    V: V,\n    w: w\n  };\n}\n\nmodule.exports.lstsqSVD = lstsqSVDWithStats;\nmodule.exports.lstsqNE = lstsqNEWithStats;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/regression/lstsq.js\n// module id = 205\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/regression/lstsq.js?")},206:/*!**************************************!*\
  !*** ./engine/statistics/topsort.js ***!
  \**************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports){eval("var inDegree = function inDegree(stat, statistics) {\n  var names = statistics.map(function (_ref) {\n    var name = _ref.name;\n    return name;\n  });\n  return stat.args.filter(function (s) {\n    return names.includes(s);\n  }).length;\n};\n\nvar topsort = function topsort(statistics) {\n  var S = statistics.filter(function (stat) {\n    return stat.args.length === 0;\n  });\n  var L = [];\n  var remaining = statistics.filter(function (stat) {\n    return !S.includes(stat);\n  });\n  var node;\n\n  while (S.length > 0) {\n    node = S.shift();\n    remaining = remaining.filter(function (n) {\n      return n !== node;\n    });\n    L.push(node);\n    S = S.concat(remaining.filter(function (stat) {\n      return inDegree(stat, remaining) === 0;\n    }));\n    remaining = remaining.filter(function (stat) {\n      return !S.includes(stat);\n    });\n  }\n\n  if (remaining.length > 0) {\n    throw new Error('Statistics are co-dependent');\n  }\n\n  return L;\n};\n\nmodule.exports = topsort;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/topsort.js\n// module id = 206\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/topsort.js?")},207:/*!******************************************!*\
  !*** ./engine/statistics/definitions.js ***!
  \******************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){eval("var Statistic = __webpack_require__(/*! ./Statistic */ 140);\n\nvar Matrix = __webpack_require__(/*! ../matrix */ 79);\n\nvar dist = __webpack_require__(/*! ./distributions-socr */ 141); // Functional definitions for statistics -- defines how they will be calculated\n// NOTE: Make sure each statistic has an entry in `metadata.json`\n\n\nmodule.exports = [// given\nStatistic('X', [], function (_ref) {\n  var X = _ref.X;\n  return X;\n}), Statistic('y', [], function (_ref2) {\n  var y = _ref2.y;\n  return y;\n}), Statistic('BHat', [], function (_ref3) {\n  var BHat = _ref3.BHat;\n  return BHat;\n}), Statistic('yHat', ['X', 'BHat'], function (_ref4) {\n  var X = _ref4.X,\n      BHat = _ref4.BHat;\n  return X.dot(BHat);\n}), // fit statistics\nStatistic('nd', ['X'], function (_ref5) {\n  var X = _ref5.X;\n  return X.shape[0];\n}), Statistic('np', ['X'], function (_ref6) {\n  var X = _ref6.X;\n  return X.shape[1];\n}), Statistic('SSE', ['y', 'yHat'], function (_ref7) {\n  var y = _ref7.y,\n      yHat = _ref7.yHat;\n  return y.sub(yHat).dotPow(2).sum();\n}), Statistic('TSS', ['y'], function (_ref8) {\n  var y = _ref8.y;\n  return y.sub(y.sum() / y.shape[0]).dotPow(2).sum();\n}), // yHat.sub(y.sum() / y.shape[0]).dotPow(2).sum()));\nStatistic('SSR', ['TSS', 'SSE'], function (_ref9) {\n  var TSS = _ref9.TSS,\n      SSE = _ref9.SSE;\n  return TSS - SSE;\n}), Statistic('Vary', ['TSS', 'nd'], function (_ref10) {\n  var TSS = _ref10.TSS,\n      nd = _ref10.nd;\n  return TSS / (nd - 1);\n}), Statistic('MSR', ['SSR', 'np'], function (_ref11) {\n  var SSR = _ref11.SSR,\n      np = _ref11.np;\n  return SSR / (np - 1);\n}), Statistic('SKEW', ['y', 'yHat', 'nd'], function (_ref12) {\n  var y = _ref12.y,\n      yHat = _ref12.yHat,\n      nd = _ref12.nd;\n  var residuals = y.sub(yHat);\n  var residMean = residuals.sum() / residuals.shape[0];\n  var residStDv = Math.sqrt(residuals.sub(residMean).dotPow(2).sum() / (nd - 1));\n  return nd * residuals.sub(residMean).dotPow(3).sum() / (nd - 1) / (nd - 2) / residStDv / residStDv / residStDv;\n}), Statistic('XKURT', ['y', 'yHat', 'nd'], function (_ref13) {\n  var y = _ref13.y,\n      yHat = _ref13.yHat,\n      nd = _ref13.nd;\n  var residuals = y.sub(yHat);\n  var residMean = residuals.sum() / residuals.shape[0];\n  var residStDv = Math.sqrt(residuals.sub(residMean).dotPow(2).sum() / (nd - 1)); // let r1 =  nd * (nd + 1) *residuals.sub(residMean).dotPow(4).sum() / (nd - 1) / (nd - 2) / (nd - 3) / residStDev / residStDv / residStDv / residStdDv;\n\n  var r1 = nd * (nd + 1) * residuals.sub(residMean).dotPow(4).sum() / (nd - 1) / (nd - 2) / (nd - 3) / residStDv / residStDv / residStDv / residStDv;\n  var r2 = 3 * (nd - 1) * (nd - 1) / (nd - 2) / (nd - 3);\n  return r1 - r2;\n}), Statistic('seSKEW', ['nd'], function (_ref14) {\n  var nd = _ref14.nd;\n  return Math.sqrt(6 / nd);\n}), Statistic('seXKURT', ['nd'], function (_ref15) {\n  var nd = _ref15.nd;\n  return Math.sqrt(24 / nd);\n}), Statistic('MSE', ['SSE', 'nd', 'np'], function (_ref16) {\n  var SSE = _ref16.SSE,\n      nd = _ref16.nd,\n      np = _ref16.np;\n  return SSE / (nd - np);\n}), Statistic('RMSE', ['MSE'], function (_ref17) {\n  var MSE = _ref17.MSE;\n  return Math.sqrt(MSE);\n}), Statistic('Rsq', ['SSE', 'TSS'], function (_ref18) {\n  var SSE = _ref18.SSE,\n      TSS = _ref18.TSS;\n  return 1 - SSE / TSS;\n}), Statistic('adjRsq', ['Rsq', 'np', 'nd'], function (_ref19) {\n  var Rsq = _ref19.Rsq,\n      nd = _ref19.nd,\n      np = _ref19.np;\n  return 1 - (1 - Rsq) * (nd - 1) / (nd - np);\n}), Statistic('F', ['MSR', 'MSE'], function (_ref20) {\n  var MSR = _ref20.MSR,\n      MSE = _ref20.MSE;\n  return MSR / MSE;\n}), Statistic('AIC', ['MSE', 'np', 'nd'], function (_ref21) {\n  var MSE = _ref21.MSE,\n      np = _ref21.np,\n      nd = _ref21.nd;\n  return Math.log10(MSE) + 2 * (np / nd);\n}), Statistic('BIC', ['MSE', 'np', 'nd'], function (_ref22) {\n  var MSE = _ref22.MSE,\n      np = _ref22.np,\n      nd = _ref22.nd;\n  return Math.log10(MSE) + np * (Math.log10(nd) / nd);\n}), Statistic('MaxAbsErr', ['y', 'yHat'], function (_ref23) {\n  var y = _ref23.y,\n      yHat = _ref23.yHat;\n  return y.sub(yHat).abs().max();\n}), Statistic('t', ['X', 'VdivwSq', 'MSE', 'BHat'], function (_ref24) {\n  var X = _ref24.X,\n      VdivwSq = _ref24.VdivwSq,\n      MSE = _ref24.MSE,\n      BHat = _ref24.BHat;\n  var sec = new Matrix(1, X.shape[1]),\n      stdModelErr,\n      i;\n\n  for (i = 0; i < X.shape[1]; i += 1) {\n    stdModelErr = Math.sqrt(VdivwSq.row(i).sum() * MSE);\n    sec.data[i] = stdModelErr;\n  }\n\n  return BHat.dotDivide(sec);\n}), Statistic('pt', ['t', 'np', 'nd'], function (_ref25) {\n  var t = _ref25.t,\n      np = _ref25.np,\n      nd = _ref25.nd;\n  var pt = t.clone();\n  pt.data.set(pt.data.map(function (t) {\n    return Math.max(0, dist.pt(t, nd - np));\n  }));\n  return pt;\n}), Statistic('pF', ['F', 'np', 'nd'], function (_ref26) {\n  var F = _ref26.F,\n      np = _ref26.np,\n      nd = _ref26.nd;\n  return Math.max(dist.pf(Math.abs(F), np, nd - np) - 1e-15, 0);\n}), Statistic('log', [\"X\"], function (_ref27) {\n  var X = _ref27.X;\n  return X.log();\n}), Statistic('mean', [\"X\"], function (_ref28) {\n  var X = _ref28.X;\n  return X.data.reduce(function (total, c) {\n    return total += c;\n  }, 0) / X.data.length;\n}), Statistic('std', [\"X\", \"mean\"], function (_ref29) {\n  var X = _ref29.X,\n      mean = _ref29.mean;\n  var diff = X.data.map(function (d) {\n    return Math.pow(d - mean, 2);\n  });\n  var diff_total = diff.reduce(function (total, c) {\n    return total += c;\n  }, 0);\n  return Math.sqrt(diff_total / X.data.length);\n}), Statistic('standardize', [\"X\", \"mean\", \"std\"], function (_ref30) {\n  var X = _ref30.X,\n      mean = _ref30.mean,\n      std = _ref30.std;\n  var standardize = X.clone();\n  standardize.data.set(standardize.data.map(function (d) {\n    return (d - mean) / std;\n  }));\n  return standardize;\n}), Statistic('RMS', [\"X\"], function (_ref31) {\n  var X = _ref31.X;\n  var rms = X.clone();\n  var SS = rms.data.map(function (r) {\n    return Math.pow(r, 2);\n  }).reduce(function (total, xi) {\n    return total += xi;\n  }, 0);\n  return Math.sqrt(SS / rms.data.length);\n}), Statistic('rescale', [\"X\", \"RMS\"], function (_ref32) {\n  var X = _ref32.X,\n      RMS = _ref32.RMS;\n  var rescale = X.clone();\n  rescale.data.set(rescale.data.map(function (d) {\n    return d / RMS;\n  }));\n  return rescale;\n}), Statistic('k_order_difference', [\"X\", \"k\"], function (_ref33) {\n  var X = _ref33.X,\n      k = _ref33.k;\n\n  var k_order_func = function k_order_func(data, k) {\n    if (k == 1) {\n      return data.map(function (d, idx) {\n        return idx < k ? null : d - data[idx - 1];\n      });\n    } else {\n      k_1_order = k_order_func(data, k - 1);\n      return data.map(function (_, idx) {\n        return idx < k ? null : k_1_order[idx] - k_1_order[idx - 1];\n      });\n    }\n  };\n\n  if (!k || isNaN(k)) {\n    return X;\n  }\n\n  var k_order = X.clone();\n  k_order.data.set(k_order_func(k_order.data, k));\n  return k_order;\n}), Statistic('sensitivity_part', ['data', 'exp', 'derivative'], function (_ref34) {\n  var data = _ref34.data,\n      exp = _ref34.exp,\n      derivative = _ref34.derivative;\n\n  if (data == undefined) {\n    return -1;\n  }\n\n  if (derivative) {\n    return data.map(function (x) {\n      return exp * Math.pow(x, exp - 1);\n    });\n  } else {\n    return data.map(function (x) {\n      return Math.pow(x, exp);\n    });\n  }\n})];\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/definitions.js\n// module id = 207\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/definitions.js?")},397:/*!*******************************************!*\
  !*** ./engine/worker/candidate-worker.js ***!
  \*******************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){eval("/*global postMessage, onmessage*/\nif (typeof window !== 'undefined') {\n  __webpack_require__(/*! ./subworkers */ 108);\n}\n\nvar UPDATE_INTERVAL = 200;\n\nvar Matrix = __webpack_require__(/*! ../matrix */ 79);\n\nvar lstsq = __webpack_require__(/*! ../regression */ 169).lstsq;\n\nvar statistics = __webpack_require__(/*! ../statistics */ 121);\n\nonmessage = function onmessage(_ref) {\n  var _ref$data = _ref.data,\n      fit = _ref$data.fit,\n      cross = _ref$data.cross,\n      validation = _ref$data.validation,\n      candidates = _ref$data.candidates,\n      jobId = _ref$data.jobId;\n  fit.X = new Matrix(fit.X.m, fit.X.n, fit.X.data);\n  fit.y = new Matrix(fit.y.m, fit.y.n, fit.y.data);\n\n  if (cross !== fit) {\n    cross.X = new Matrix(cross.X.m, cross.X.n, cross.X.data);\n    cross.y = new Matrix(cross.y.m, cross.y.n, cross.y.data);\n  }\n\n  var model = {\n    fit: fit,\n    cross: cross,\n    validation: validation\n  };\n  var results = candidates.map(function (_ref2, i) {\n    var fit = _ref2.fit,\n        cross = _ref2.cross,\n        validation = _ref2.validation,\n        lag = _ref2.lag;\n\n    // Can't find a fit if exponent is -1 and divisor is 0\n    if (!fit) {\n      return NaN;\n    } // reconstruct matrices (they were deconstructed for transport)\n\n\n    fit = {\n      X: model.fit.X.hstack(new Matrix(fit.m, fit.n, fit.data)).lo(lag),\n      y: model.fit.y.lo(lag)\n    };\n    cross = {\n      X: model.cross.X.hstack(new Matrix(cross.m, cross.n, cross.data)).lo(lag),\n      y: model.cross.y.lo(lag)\n    };\n\n    if (i % UPDATE_INTERVAL === 0) {\n      postMessage({\n        type: 'progress',\n        data: i,\n        jobId: jobId\n      });\n    }\n\n    try {\n      // Compute stats for fit, then take t and P(t) (these come from fit data)\n      var stats = statistics(lstsq(fit.X, fit.y));\n      var t = stats.t.get(0, stats.t.shape[0] - 1);\n      var pt = stats.pt.get(0, stats.pt.shape[0] - 1); // Then, use the cross data to compute the rest of the statistics\n\n      stats = statistics(lstsq(cross.X, cross.y, stats.weights));\n      stats.coeff = stats.weights.get(0, stats.weights.shape[0] - 1);\n      stats.t = t;\n      stats.pt = pt;\n      delete stats.weights;\n      return stats;\n    } catch (e) {\n      console.error(e);\n      return NaN;\n    }\n  });\n  postMessage({\n    type: 'result',\n    data: results,\n    jobId: jobId\n  });\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/worker/candidate-worker.js\n// module id = 397\n// module chunks = 2\n\n//# sourceURL=webpack:///./engine/worker/candidate-worker.js?")},78:/*!*************************!*\
  !*** ./engine/utils.js ***!
  \*************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction nchars(n, _char) {\n  n = Math.max(0, n);\n  return Array(n + 1).join(_char);\n}\n\nvar nspaces = function nspaces(n) {\n  return nchars(n, ' ');\n};\n\nfunction pad(width, val) {\n  val = val || '';\n  return nspaces(width - ('' + val).length) + val;\n}\n\nvar range = module.exports.range = function (start, end) {\n  if (start >= end) {\n    return [];\n  }\n\n  return Array(end - start).join(' ').split(' ').map(function (_, i) {\n    return i + start;\n  });\n};\n\nvar zeros = module.exports.zeros = function (n) {\n  return Array(n).join(' ').split(' ').map(function () {\n    return 0;\n  });\n};\n\nvar sum = module.exports.sum = function (arr) {\n  return arr.reduce(function (tot, curr) {\n    return tot + curr;\n  });\n};\n\nmodule.exports.convertRange = function (str, length) {\n  var range, start, end;\n\n  if (typeof str === 'number') {\n    return str < 0 ? [length + str] : [str];\n  }\n\n  if (typeof str !== 'string') {\n    return str.map(function (ind) {\n      return ind < 0 ? length + ind : ind;\n    });\n  }\n\n  if ((range = str.split(':')).length > 1) {\n    start = parseInt(range[0]) || 0;\n    end = parseInt(range[1]) || length;\n\n    if (start < 0) {\n      start = length + start;\n    }\n\n    if (end < 0) {\n      end = length + end;\n    }\n\n    return module.exports.range(start, end);\n  }\n\n  throw new TypeError('Invalid range');\n};\n\nmodule.exports.formatNum = function (leftwidth, rightwidth, val) {\n  var nilDecimalChar = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ' ';\n  val = '' + val;\n  var match = val.match(/(NaN|-?Infinity|-?\\d*)\\.?(\\d*)/),\n      whole = match[1],\n      frac = match[2],\n      repr = '';\n\n  if (frac.length > rightwidth) {\n    frac = frac.slice(0, rightwidth);\n  }\n\n  repr += nspaces(leftwidth - whole.length) + whole;\n\n  if (frac !== '' || rightwidth > 0) {\n    repr += '.';\n    repr += frac.slice(0, rightwidth) + nchars(rightwidth - frac.length, nilDecimalChar);\n  } else {\n    repr += nspaces(rightwidth + 1);\n  }\n\n  return repr;\n};\n\nvar padAll = module.exports.padAll = function (lwidth, str) {\n  if (Array.isArray(str)) {\n    return str.map(function (s) {\n      return padAll(lwidth + s.length, s);\n    });\n  } else if (typeof str === 'string') {\n    return str.split('\\n').map(function (s) {\n      return pad(lwidth + s.length, s);\n    }).join('\\n');\n  }\n\n  return pad(lwidth, str);\n};\n\nvar clone = module.exports.clone = function (obj) {\n  if (_typeof(obj) !== 'object') {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(clone);\n  }\n\n  var newObj = {};\n  Object.keys(obj).forEach(function (key) {\n    return newObj[key] = clone(obj[key]);\n  });\n  return newObj;\n};\n\nvar split = module.exports.split = function (arr, n) {\n  var results = range(0, n).map(function () {\n    return [];\n  });\n  var i;\n\n  for (i = 0; i < arr.length; i += 1) {\n    results[i % n].push(arr[i]);\n  }\n\n  return results;\n};\n\nvar splitToSize = module.exports.splitToSize = function (arr, n) {\n  var results = [];\n  var subset;\n  var i;\n\n  for (i = 0, subset = []; i < arr.length; i += 1) {\n    subset.push(arr[i]);\n\n    if ((i + 1) % n === 0) {\n      results.push(subset);\n      subset = [];\n    }\n  }\n\n  if (i % n !== 0) {\n    results.push(subset);\n  }\n\n  return results;\n};\n\nmodule.exports.join = function (arr) {\n  return [].concat.apply([], arr);\n};\n\nmodule.exports.sign = function (x) {\n  return x < 0 ? -1 : x > 0 ? 1 : 0;\n};\n\nmodule.exports.argmax = function (arr) {\n  return arr.indexOf(Math.max.apply(null, arr));\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/utils.js\n// module id = 78\n// module chunks = 0 1 2\n\n//# sourceURL=webpack:///./engine/utils.js?")},79:/*!********************************!*\
  !*** ./engine/matrix/index.js ***!
  \********************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(/*! ./Matrix */ 204);\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/matrix/index.js\n// module id = 79\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/matrix/index.js?")}});