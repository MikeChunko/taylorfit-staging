!function(){this.global=this,this.window=this}(),function(n){function e(r){if(t[r])return t[r].exports;var a=t[r]={i:r,l:!1,exports:{}};return n[r].call(a.exports,a,a.exports,e),a.l=!0,a.exports}var t={};e.m=n,e.c=t,e.d=function(n,t,r){e.o(n,t)||Object.defineProperty(n,t,{configurable:!1,enumerable:!0,get:r})},e.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(t,"a",t),t},e.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},e.p="",e(e.s=388)}({108:/*!*************************************!*\
  !*** ./engine/worker/subworkers.js ***!
  \*************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){eval("(function () {\n  /* Detect if we're in a worker or not */\n  var isWorker = false;\n\n  try {\n    document;\n  } catch (e) {\n    isWorker = true;\n  }\n\n  if (isWorker) {\n    // Replace self.postMessage because webpack-dev-server doesn't recognize\n    // workers\n    var oldPostMessage = self.postMessage;\n\n    self.postMessage = function (msg, otherthing) {\n      try {\n        oldPostMessage(msg, otherthing);\n      } catch (e) {\n        console.warn(e.message);\n      }\n    }; // For some reason, nested workers on firefox sucks. So, just polyfill all\n    // of the browsers to make this work\n\n\n    if (true\n    /* we don't really need to check this */\n    ) {\n        self.Worker = function (path) {\n          var that = this;\n          this.id = Math.random().toString(36).substr(2, 5);\n          this.eventListeners = {\n            \"message\": []\n          };\n          self.addEventListener(\"message\", function (e) {\n            if (e.data._from === that.id) {\n              var newEvent = new MessageEvent(\"message\");\n              newEvent.initMessageEvent(\"message\", false, false, e.data.message, that, \"\", null, []);\n              that.dispatchEvent(newEvent);\n\n              if (that.onmessage) {\n                that.onmessage(newEvent);\n              }\n            }\n          });\n          var location = self.location.pathname;\n          var absPath = path; //location.substring(0, location.lastIndexOf('/')) + '/' + path;\n\n          self.postMessage({\n            _subworker: true,\n            cmd: 'newWorker',\n            id: this.id,\n            path: absPath\n          });\n        };\n\n        Worker.prototype = {\n          onerror: null,\n          onmessage: null,\n          postMessage: function postMessage(message) {\n            self.postMessage({\n              _subworker: true,\n              id: this.id,\n              cmd: 'passMessage',\n              message: message\n            });\n          },\n          terminate: function terminate() {\n            self.postMessage({\n              _subworker: true,\n              cmd: 'terminate',\n              id: this.id\n            });\n          },\n          addEventListener: function addEventListener(type, listener, useCapture) {\n            if (this.eventListeners[type]) {\n              this.eventListeners[type].push(listener);\n            }\n          },\n          removeEventListener: function removeEventListener(type, listener, useCapture) {\n            if (!(type in this.eventListeners)) return;\n            var index = this.eventListeners[type].indexOf(listener);\n\n            if (index !== -1) {\n              this.eventListeners[type].splice(index, 1);\n            }\n          },\n          dispatchEvent: function dispatchEvent(event) {\n            var listeners = this.eventListeners[event.type];\n\n            for (var i = 0; i < listeners.length; i++) {\n              listeners[i](event);\n            }\n          }\n        };\n      }\n  }\n\n  var allWorkers = {};\n  var cmds = {\n    newWorker: function newWorker(event) {\n      var worker = new Worker(event.data.path);\n      worker.addEventListener(\"message\", function (e) {\n        var envelope = {\n          _from: event.data.id,\n          message: e.data\n        };\n        event.target.postMessage(envelope);\n      });\n      allWorkers[event.data.id] = worker;\n    },\n    terminate: function terminate(event) {\n      allWorkers[event.data.id].terminate();\n    },\n    passMessage: function passMessage(event) {\n      allWorkers[event.data.id].postMessage(event.data.message);\n    }\n  };\n\n  var messageRecieved = function messageRecieved(event) {\n    if (event.data._subworker) {\n      cmds[event.data.cmd](event);\n    }\n  };\n  /* Hijack Worker */\n\n\n  var oldWorker = window.Worker;\n\n  window.Worker = function (path) {\n    var blobIndex = path.indexOf('blob:');\n\n    if (blobIndex !== -1 && blobIndex !== 0) {\n      path = path.substring(blobIndex);\n    }\n\n    var newWorker = new oldWorker(path);\n    newWorker.addEventListener(\"message\", messageRecieved);\n    return newWorker;\n  };\n})();\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/worker/subworkers.js\n// module id = 108\n// module chunks = 0 1 2 3\n\n//# sourceURL=webpack:///./engine/worker/subworkers.js?")},121:/*!************************************!*\
  !*** ./engine/statistics/index.js ***!
  \************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){eval("var Statistic = __webpack_require__(/*! ./Statistic */ 140);\n\nvar topsort = __webpack_require__(/*! ./topsort */ 206);\n\nvar definitions = __webpack_require__(/*! ./definitions */ 207);\n\nvar metadata = __webpack_require__(/*! ./metadata.json */ 168); // used for t-stat calculations\n//let VdivwSq = V.dotDivide(w).dotPow(2);\n\n\nvar sorted = topsort(definitions);\nvar noShow = metadata.filter(function (_ref) {\n  var show = _ref.show;\n  return !show;\n});\n\nmodule.exports = function (predefinedStats) {\n  var stats = sorted.reduce(function (calculatedStats, stat) {\n    return stat.calc(calculatedStats);\n  }, predefinedStats);\n  /*\n  for (let key of noShow) {\n    delete stats[key];\n  }\n   */\n\n  return stats;\n};\n\nmodule.exports.compute = function (stat, args) {\n  stat_def = definitions.find(function (s) {\n    return s.name === stat;\n  });\n\n  if (stat_def == null) {\n    throw new ReferenceError('Cannot find statistic \\'' + stat + '\\'');\n  }\n\n  return stat_def.calc(args)[stat];\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/index.js\n// module id = 121\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/index.js?")},122:/*!***************************************************!*\
  !*** ./interface/components/transform/label.json ***!
  \***************************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports){eval('module.exports = {"LOG":"log","K_ORDER_DIFFERENCE":"K-Order_difference","STANDARDIZE":"Standardize","RESCALE":"Scale_by_RMS","Transform":{"delete":0,"log":1,"k_order_diff":2,"standardize":3,"rescale":4}}\n\n//////////////////\n// WEBPACK FOOTER\n// ./interface/components/transform/label.json\n// module id = 122\n// module chunks = 0 1\n\n//# sourceURL=webpack:///./interface/components/transform/label.json?')},139:/*!************************************************!*\
  !*** ./engine/regression/svd-golub-reinsch.js ***!
  \************************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){"use strict";eval("\n\nvar Matrix = __webpack_require__(/*! ../matrix */ 79);\n\nfunction pythag(a, b) {\n  var absa = Math.abs(a),\n      absb = Math.abs(b);\n  return absa > absb ? absa * Math.sqrt(1 + Math.pow(absb / absa, 2)) : absb === 0 ? 0 : absb * Math.sqrt(1 + Math.pow(absa / absb, 2));\n}\n/**\n * Translation of the SVD algorithm published in Numer. Math. 14, 403-420 (1970)\n * by G. H. Golub and C. Reinsch.\n *\n * Source: http://cs.brown.edu/courses/csci0530/current/homeworks/svd.py\n *\n * @param {Matrix<m,n>} A Matrix to decompose (m >= n)\n * @return {[Matrix<m,m>, Matrix<m,n>, Matrix<n,n>]} [U, E, V] s.t. A = U*E*V\n */\n\n\nfunction svd(A) {\n  var eps = Number.EPSILON,\n      tol = Number.MIN_VALUE / eps;\n\n  if (1.0 + eps <= 1.0) {\n    throw new Error('Make eps bigger');\n  }\n\n  if (tol <= 0.0) {\n    throw new Error('Make tol bigger');\n  }\n\n  var itmax = 50,\n      u = A.clone(),\n      m = u.shape[0],\n      n = u.shape[1],\n      e = [],\n      q = [],\n      v = new Matrix(n, n),\n      g = 0.0,\n      x = 0.0,\n      i,\n      j,\n      k,\n      l,\n      s,\n      f,\n      h,\n      y,\n      iteration,\n      gotoTestFConvergence,\n      z,\n      c,\n      l1;\n\n  if (m < n) {\n    throw new Error('m is less than n');\n  }\n\n  for (i = 0; i < n; i++) {\n    e[i] = g;\n    s = 0.0;\n    l = i + 1;\n\n    for (j = i; j < m; j++) {\n      s += u.data[j * n + i] * u.data[j * n + i];\n    }\n\n    if (s < tol) {\n      g = 0.0;\n    } else {\n      f = u.data[i * n + i];\n\n      if (f < 0.0) {\n        g = Math.sqrt(s);\n      } else {\n        g = -Math.sqrt(s);\n      }\n\n      h = f * g - s;\n      u.data[i * n + i] = f - g;\n\n      for (j = l; j < n; j++) {\n        s = 0.0;\n\n        for (k = i; k < m; k++) {\n          s += u.data[k * n + i] * u.data[k * n + j];\n        }\n\n        f = s / h;\n\n        for (k = i; k < m; k++) {\n          u.data[k * n + j] = u.data[k * n + j] + f * u.data[k * n + i];\n        }\n      }\n    }\n\n    q[i] = g;\n    s = 0.0;\n\n    for (j = l; j < n; j++) {\n      s = s + u.data[i * n + j] * u.data[i * n + j];\n    }\n\n    if (s <= tol) {\n      g = 0.0;\n    } else {\n      f = u.data[i * n + i + 1];\n\n      if (f < 0.0) {\n        g = Math.sqrt(s);\n      } else {\n        g = -Math.sqrt(s);\n      }\n\n      h = f * g - s;\n      u.data[i * n + i + 1] = f - g;\n\n      for (j = l; j < n; j++) {\n        e[j] = u.data[i * n + j] / h;\n      }\n\n      for (j = l; j < m; j++) {\n        s = 0.0;\n\n        for (k = l; k < n; k++) {\n          s = s + u.data[j * n + k] * u.data[i * n + k];\n        }\n\n        for (k = l; k < n; k++) {\n          u.data[j * n + k] = u.data[j * n + k] + s * e[k];\n        }\n      }\n    }\n\n    y = Math.abs(q[i]) + Math.abs(e[i]);\n\n    if (y > x) {\n      x = y;\n    }\n  } // accumulation of right hand transformations\n\n\n  for (i = n - 1; i > -1; i--) {\n    if (g !== 0) {\n      h = g * u.data[i * n + i + 1];\n\n      for (j = l; j < n; j++) {\n        v.data[j * n + i] = u.data[i * n + j] / h;\n      }\n\n      for (j = l; j < n; j++) {\n        s = 0.0;\n\n        for (k = l; k < n; k++) {\n          s += u.data[i * n + k] * v.data[k * n + j];\n        }\n\n        for (k = l; k < n; k++) {\n          v.data[k * n + j] += s * v.data[k * n + i];\n        }\n      }\n    }\n\n    for (j = l; j < n; j++) {\n      v.data[i * n + j] = 0.0;\n      v.data[j * n + i] = 0.0;\n    }\n\n    v.data[i * n + i] = 1.0;\n    g = e[i];\n    l = i;\n  } // accumulation of left hand transformations\n\n\n  for (i = n - 1; i > -1; i--) {\n    l = i + 1;\n    g = q[i];\n\n    for (j = l; j < n; j++) {\n      u.data[i * n + j] = 0.0;\n    }\n\n    if (g !== 0.0) {\n      h = u.data[i * n + i] * g;\n\n      for (j = l; j < n; j++) {\n        s = 0.0;\n\n        for (k = l; k < m; k++) {\n          s += u.data[k * n + i] * u.data[k * n + j];\n        }\n\n        f = s / h;\n\n        for (k = i; k < m; k++) {\n          u.data[k * n + j] += f * u.data[k * n + i];\n        }\n      }\n\n      for (j = i; j < m; j++) {\n        u.data[j * n + i] = u.data[j * n + i] / g;\n      }\n    } else {\n      for (j = i; j < m; j++) {\n        u.data[j * n + i] = 0.0;\n      }\n    }\n\n    u.data[i * n + i] += 1.0;\n  } // diagonalization of the bidiagonal form\n\n\n  eps = eps * x;\n\n  for (k = n - 1; k > -1; k--) {\n    for (iteration = 0; iteration < itmax; iteration++) {\n      // test f splitting\n      for (l = k; l > -1; l--) {\n        gotoTestFConvergence = false;\n\n        if (Math.abs(e[l]) <= eps) {\n          // goto test f convergence\n          gotoTestFConvergence = true;\n          break;\n        }\n\n        if (Math.abs(q[l - 1]) <= eps) {\n          // goto cancellation\n          break;\n        }\n      }\n\n      if (!gotoTestFConvergence) {\n        // cancellation of e[l] if l>0\n        c = 0.0;\n        s = 1.0;\n        l1 = l - 1;\n\n        for (i = l; i < k + 1; i++) {\n          f = s * e[i];\n          e[i] = c * e[i];\n\n          if (Math.abs(f) <= eps) {\n            // goto test f convergence\n            break;\n          }\n\n          g = q[i];\n          h = pythag(f, g);\n          q[i] = h;\n          c = g / h;\n          s = -f / h;\n\n          for (j = 0; j < m; j++) {\n            y = u.data[j * n + l1];\n            z = u.data[j * n + i];\n            u.data[j * n + l1] = y * c + z * s;\n            u.data[j * n + i] = -y * s + z * c;\n          }\n        }\n      } // test f convergence\n\n\n      z = q[k];\n\n      if (l === k) {\n        // convergence\n        if (z < 0.0) {\n          // q[k] is made non-negative\n          q[k] = -z;\n\n          for (j = 0; j < n; j++) {\n            v.data[j * n + k] = -v.data[j * n + k];\n          }\n        }\n\n        break; // break out of iteration loop and move on to next k value\n      }\n\n      if (iteration >= itmax - 1) {\n        throw new Error('SVD: No convergence');\n      } // shift from bottom 2x2 minor\n\n\n      x = q[l];\n      y = q[k - 1];\n      g = e[k - 1];\n      h = e[k];\n      f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);\n      g = pythag(f, 1.0);\n\n      if (f < 0) {\n        f = ((x - z) * (x + z) + h * (y / (f - g) - h)) / x;\n      } else {\n        f = ((x - z) * (x + z) + h * (y / (f + g) - h)) / x;\n      } // next QR transformation\n\n\n      c = 1.0;\n      s = 1.0;\n\n      for (i = l + 1; i < k + 1; i++) {\n        g = e[i];\n        y = q[i];\n        h = s * g;\n        g = c * g;\n        z = pythag(f, h);\n        e[i - 1] = z;\n        c = f / z;\n        s = h / z;\n        f = x * c + g * s;\n        g = -x * s + g * c;\n        h = y * s;\n        y = y * c;\n\n        for (j = 0; j < n; j++) {\n          x = v.data[j * n + i - 1];\n          z = v.data[j * n + i];\n          v.data[j * n + i - 1] = x * c + z * s;\n          v.data[j * n + i] = -x * s + z * c;\n        }\n\n        z = pythag(f, h);\n        q[i - 1] = z;\n        c = f / z;\n        s = h / z;\n        f = c * g + s * y;\n        x = -s * g + c * y;\n\n        for (j = 0; j < m; j++) {\n          y = u.data[j * n + i - 1];\n          z = u.data[j * n + i];\n          u.data[j * n + i - 1] = y * c + z * s;\n          u.data[j * n + i] = -y * s + z * c;\n        }\n      }\n\n      e[l] = 0.0;\n      e[k] = f;\n      q[k] = x; // goto test f splitting\n    }\n  }\n\n  return [u, q, v];\n}\n\nmodule.exports = svd;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/regression/svd-golub-reinsch.js\n// module id = 139\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/regression/svd-golub-reinsch.js?")},140:/*!****************************************!*\
  !*** ./engine/statistics/Statistic.js ***!
  \****************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports){eval('function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar defaults = [\'X\', \'y\', \'BHat\'];\n\nvar Statistic = /*#__PURE__*/function () {\n  function Statistic(name, args, fn, description) {\n    _classCallCheck(this, Statistic);\n\n    this.name = name;\n    this.args = args;\n    this.fn = fn;\n  }\n\n  _createClass(Statistic, [{\n    key: "calc",\n    value: function calc(statistics) {\n      statistics[this.name] = this.fn(statistics);\n      return statistics;\n    }\n  }, {\n    key: "inspect",\n    value: function inspect(depth) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        stylize: function stylize(x) {\n          return \'\' + x;\n        }\n      };\n      return "".concat(this.name, "(").concat(this.args, ")");\n    }\n  }]);\n\n  return Statistic;\n}();\n\nmodule.exports = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return _construct(Statistic, args);\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/Statistic.js\n// module id = 140\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/Statistic.js?')},141:/*!*************************************************!*\
  !*** ./engine/statistics/distributions-socr.js ***!
  \*************************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction statcom(q, i, j, b) {\n  var zz = 1,\n      z = zz,\n      k = i;\n\n  while (k <= j) {\n    zz *= q * k / (k - b);\n    z += zz;\n    k += 2;\n  }\n\n  return z;\n}\n/**\n * Two sided T-distribution estimator.\n *\n * Source: https://github.com/SOCR/HTML5_WebSite\n *         (Applets/Normal_T_Chi2_F_Tables.html)\n * License: GNU LGPL\n *\n * @param {Number} t T-statistic for some independent variable\n * @param {Number} n Degrees of freedom\n * @return {Number} 2-tailed p-value for the t statistic ( Pr(t) )\n */\n\n\nfunction pt(t, n) {\n  t = Math.abs(t);\n  var w = t / Math.sqrt(n),\n      th = Math.atan(w);\n\n  if (n === 1) {\n    return 1 - th / (Math.PI / 2);\n  }\n\n  var sth = Math.sin(th),\n      cth = Math.cos(th);\n\n  if (n % 2 === 1) {\n    return 1 - (th + sth * cth * statcom(cth * cth, 2, n - 3, -1)) / (Math.PI / 2);\n  }\n\n  return 1 - sth * statcom(cth * cth, 1, n - 3, -1);\n}\n/**\n * Fisher's F-density estimator.\n *\n * Source: https://github.com/SOCR/HTML5_WebSite\n *         (Applets/Normal_T_Chi2_F_Tables.html)\n * License: GNU LGPL\n *\n * @param {Number} f  F value for the model\n * @param {Number} n1 # of terms in the model\n * @param {Number} n2 Degrees of freedom\n * @return {Number} Probability of (F < f)\n */\n\n\nfunction pf(f, n1, n2) {\n  var x = n2 / (n1 * f + n2);\n\n  if (n1 % 2 === 0) {\n    return statcom(1 - x, n2, n1 + n2 - 4, n2 - 2) * Math.pow(x, n2 / 2);\n  }\n\n  if (n2 % 2 === 0) {\n    return 1 - statcom(x, n1, n1 + n2 - 4, n1 - 2) * Math.pow(1 - x, n1 / 2);\n  }\n\n  var th = Math.atan(Math.sqrt(n1 * f / n2)),\n      a = th / (Math.PI / 2),\n      sth = Math.sin(th),\n      cth = Math.cos(th);\n\n  if (n2 > 1) {\n    a += sth * cth * statcom(cth * cth, 2, n2 - 3, -1) / (Math.PI / 2);\n  }\n\n  if (n1 === 1) {\n    return 1 - a;\n  }\n\n  var c = 4 * statcom(sth * sth, n2 + 1, n1 + n2 - 4, n2 - 2) * sth * Math.pow(cth, n2) / Math.PI;\n\n  if (n2 === 1) {\n    return 1 - a + c / 2;\n  }\n\n  var k = 2;\n\n  while (k <= (n2 - 1) / 2) {\n    c *= k / (k - 0.5);\n    k += 1;\n  }\n\n  return 1 - a + c;\n}\n\nmodule.exports.pt = pt;\nmodule.exports.pf = pf;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/distributions-socr.js\n// module id = 141\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/distributions-socr.js?")},168:/*!*****************************************!*\
  !*** ./engine/statistics/metadata.json ***!
  \*****************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports){eval('module.exports = [{"id":"X","show":false},{"id":"y","show":false},{"id":"v","show":false},{"id":"w","show":false},{"id":"VdivwSq","show":false},{"id":"BHat","show":false},{"id":"yHat","show":false},{"id":"Vary","show":false},{"id":"nd","globalOnly":true,"format":"int","description":"Number of data (rows) in the corresponding Data Table (Fit, Cross or Validate)"},{"id":"np","globalOnly":true,"format":"int","description":"Number of parameters (or terms) in the Current Model"},{"id":"SSE","sort":">","description":"Sum of squares of the residual errors"},{"id":"TSS","globalOnly":true,"description":"Total sum of squares"},{"id":"SSR","description":"Sum of squares due to regression"},{"id":"MSE","description":"Mean square error (variance of the residual errors)"},{"id":"PLACEHOLDER"},{"id":"Rsq","sort":"<","description":"Square of the multiple correlation coefficient"},{"id":"adjRsq","sort":"<","description":"Adjusted R-squared - similar to Rsq, but penalizes for model complexity"},{"id":"PLACEHOLDER"},{"id":"MaxAbsErr","displayName":"Max|Err|","sort":">","description":"Maximum of the absolute value of the residual errors"},{"id":"RMSE","sort":">","description":"Square root of the mean square error"},{"id":"SKEW","sort":"<","description":"Skewness"},{"id":"XKURT","sort":"<","description":"Excess kurtosis"},{"id":"PLACEHOLDER"},{"id":"AIC","sort":">","description":"Akaike Information Criterion"},{"id":"BIC","sort":">","description":"Bayesian Information Criterion"},{"id":"F","sort":"<","description":"F-statistic"},{"id":"pF","displayName":"p(F)","sort":">","description":"Probability that a larger value of the F-statistic occurs by chance. This is a test of overall model fitness."},{"id":"PLACEHOLDER"},{"id":"seSKEW","displayName":"s.e. SKEW","sort":"<","description":"Estimated standard error of the skewness. If SKEW > 2*s.e.SKEW, there is evidence that residual errors are not normally distributed."},{"id":"seXKURT","displayName":"s.e. XKURT","sort":"<","description":"Estimated standard error of the kurtosis. If |ExKurt|> 2*s.e.ExKurt, there is evidence that residual errors are not normally distributed."},{"id":"t","sort":"|<|","candidateOnly":true,"default":true,"description":"The t-statistic used to determine how significant this term is. A value above about 2.0 is usually considered significant."},{"id":"pt","displayName":"p(t)","sort":">","candidateOnly":true,"default":true,"description":"The probability that this term occurs by chance. Cell is colored green if p(t) > alpha (default alpha = 0.05)."},{"id":"stdev","show":false},{"id":"mean","show":false},{"id":"weights","show":false},{"id":"log","show":false},{"id":"mean","show":false},{"id":"std","show":false},{"id":"standardize","show":false},{"id":"RMS","show":false},{"id":"rescale","show":false},{"id":"k_order_difference","show":false}]\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/metadata.json\n// module id = 168\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/metadata.json?')},169:/*!************************************!*\
  !*** ./engine/regression/index.js ***!
  \************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){eval("// lstsqSVD | lstsqNE\nvar METHOD = 'lstsqSVD';\nmodule.exports.svd = __webpack_require__(/*! ./svd-golub-reinsch */ 139);\nmodule.exports.lstsq = __webpack_require__(/*! ./lstsq */ 205)[METHOD];\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/regression/index.js\n// module id = 169\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/regression/index.js?")},203:/*!************************!*\
  !*** ./engine/perf.js ***!
  \************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){eval("var utils = __webpack_require__(/*! ./utils */ 78);\n\nvar appStart = Date.now();\n\nif (typeof performance === 'undefined') {\n  var PerformanceMark = function PerformanceMark(name) {\n    this.startTime = Date.now() - appStart;\n    this.duration = 0;\n    this.entryType = 'mark';\n    this.name = name;\n    entries.push(this);\n  };\n\n  var PerformanceMeasure = function PerformanceMeasure(name, startMark, endMark) {\n    var timeNow = Date.now() - appStart;\n    var i = entries.length - 1;\n\n    while (i >= 0 && entries[i].name !== startMark && entries[i].type !== 'mark') {\n      i -= 1;\n    }\n\n    if (i >= 0) {\n      startMark = entries[i];\n    } else {\n      startMark = {\n        startTime: 0\n      };\n    }\n\n    i = entries.length - 1;\n\n    while (i >= 0 && entries[i].name !== endMark && entries[i].type !== 'mark') {\n      i -= 1;\n    }\n\n    if (i >= 0) {\n      endMark = entries[i];\n    } else {\n      endMark = {\n        startTime: timeNow\n      };\n    }\n\n    this.startTime = startMark.startTime;\n    this.duration = endMark.startTime - startMark.startTime;\n    this.name = name;\n    this.entryType = 'measure';\n    entries.push(this);\n  };\n\n  var entries = [];\n  var performance = {};\n\n  performance.mark = function (name) {\n    new PerformanceMark(name);\n  };\n\n  performance.measure = function (name, startMark, endMark) {\n    new PerformanceMeasure(name, startMark, endMark);\n  };\n\n  performance.getEntriesByName = function (name) {\n    return entries.filter(function (e) {\n      return e.name === name;\n    });\n  };\n\n  performance.getEntries = function () {\n    return entries.slice();\n  };\n\n  performance.getEntriesByType = function (type) {\n    return entries.filter(function (e) {\n      return e.entryType === type;\n    });\n  };\n}\n\nfunction start(name) {\n  performance.mark(name + ':start');\n}\n\nfunction end(name) {\n  performance.mark(name + ':end');\n  performance.measure(name + ':measure', name + ':start', name + ':end');\n}\n\nfunction getMeanDuration(name) {\n  var measures = performance.getEntriesByName(name + ':measure');\n  return measures.reduce(function (sum, measure) {\n    return sum + measure.duration;\n  }, 0) / measures.length;\n}\n\nfunction log(name) {\n  var logFn = console.log;\n\n  if (console.debug) {\n    logFn = console.debug;\n  }\n\n  logFn(\"[Performance] \".concat(name, \": \").concat(getMeanDuration(name), \"ms (avg)\"));\n}\n\nfunction report(name) {\n  var nLatestRecords = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var logFn = console.log;\n\n  if (console.debug) {\n    logFn = console.debug;\n  }\n\n  var measures = performance.getEntriesByName(name + ':measure').slice(-nLatestRecords);\n  var padWidth = measures.reduce(function (best, m) {\n    return Math.max(best, Math.floor(Math.log10(m.duration) + 1));\n  }, 0);\n  logFn(\"[Performance] \".concat(name, \" (report)\"));\n  measures.forEach(function (measure) {\n    return logFn(\"  \".concat(name, \": \").concat(utils.formatNum(padWidth, 4, measure.duration, 0), \"ms\"));\n  });\n}\n\nmodule.exports = {\n  start: start,\n  end: end,\n  getMeanDuration: getMeanDuration,\n  log: log,\n  report: report\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/perf.js\n// module id = 203\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/perf.js?")},204:/*!*********************************!*\
  !*** ./engine/matrix/Matrix.js ***!
  \*********************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar utils = __webpack_require__(/*! ../utils */ 78);\n/**\n * Private members\n *\n * @private\n */\n\n\nvar _data = Symbol('data');\n\nvar _m = Symbol('m');\n\nvar _n = Symbol('n'); // Maximum number of decimal points to print\n\n\nvar PRINT_DECIMALS = 5; // Number.MAX_SAFE_INTEGER value [ i.e. doesn't support :( ]\n\nvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n/**\n * Swap rows `i` and `j` in matrix `m` in place.\n *\n * @param {Matrix} m\n * @param {number} i\n * @param {number} j\n */\n\nfunction swapRows(m, i, j) {\n  var k, temp;\n\n  for (k = 0; k < m[_n]; k += 1) {\n    temp = m[_data][j * m[_n] + k];\n    m[_data][j * m[_n] + k] = m[_data][i * m[_n] + k];\n    m[_data][i * m[_n] + k] = temp;\n  }\n}\n/**\n * Divide row `i` in both matrix `m` and matrix `inv` by `factor`.\n *\n * @param {Matrix} m\n * @param {Matrix} inv\n * @param {number} i\n * @param {number} j\n */\n\n\nfunction divideRow(m, inv, i, factor) {\n  var k, temp;\n\n  for (k = 0; k < m[_n]; k += 1) {\n    m[_data][i * m[_n] + k] /= factor;\n    inv[_data][i * m[_n] + k] /= factor;\n  }\n}\n/**\n * Subtract multiple of row `i` and column `j` from every row in `m` and `inv`.\n *\n * @param {Matrix} m\n * @param {Matrix} inv\n * @param {number} i\n * @param {number} j\n */\n\n\nfunction subtractRowMultiple(m, inv, i, j) {\n  var k, l, factor;\n\n  for (l = 0; l < m[_m]; l += 1) {\n    factor = m[_data][l * m[_n] + j];\n\n    if (l !== i) {\n      for (k = 0; k < m[_n]; k += 1) {\n        m[_data][l * m[_n] + k] -= m[_data][i * m[_n] + k] * factor;\n        inv[_data][l * m[_n] + k] -= inv[_data][i * m[_n] + k] * factor;\n      }\n    }\n  }\n}\n/**\n * A speedy 2-dimensional matrix implementation.\n *\n * @class Matrix\n */\n\n\nvar Matrix = /*#__PURE__*/function () {\n  /**\n   * Creates a new Matrix of size <n, m>, using `stuff`.\n   *\n   * If `stuff` is a Float64Array, then the reference will be used. Otherwise,\n   * its contents will be copied into a new Float64Array.\n   *\n   * @param {number | number[][]}       n     Number of columns (or nested arrays\n   *                                          that look like a matrix)\n   * @param {number}                    m     Number of rows\n   * @param {Float64Array | number[][]} stuff Items to populate the matrix\n   */\n  function Matrix(m, n, stuff) {\n    var skip_NaN = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    _classCallCheck(this, Matrix);\n\n    if (m instanceof Matrix) {\n      return m;\n    }\n\n    if (Array.isArray(m)) {\n      return Matrix.from(m);\n    }\n\n    if (stuff != null) {\n      stuff = stuff instanceof Float64Array ? stuff : Float64Array.from(stuff);\n\n      if (stuff.length !== m * n) {\n        throw new Error('Array does not match the specified dimensions');\n      }\n    } else {\n      stuff = new Float64Array(m * n);\n    } // Filter Out NaN Columns\n\n\n    var valid_columns = new Array(n).fill(true);\n    var valid_column_count = n; //i: Iterate over columns\n\n    for (var i = 0; i < n; i++) {\n      // j: iterate over rows\n      for (var j = 0; j < m; j++) {\n        if (!skip_NaN && isNaN(stuff[j * n + i])) {\n          valid_columns[i] = false;\n          valid_column_count -= 1;\n          break;\n        }\n      }\n    } // If NaN Column Found, create new Float64 Array & Populate\n\n\n    if (valid_column_count != n) {\n      var new_stuff = new Float64Array(valid_column_count * m);\n      var iterator = 0;\n\n      for (var _i = 0; _i < m * n; _i++) {\n        var curr_col = _i % n;\n\n        if (valid_columns[curr_col]) {\n          new_stuff[iterator++] = stuff[_i];\n        }\n      }\n\n      stuff = new_stuff;\n      n = valid_column_count;\n    }\n\n    this[_data] = stuff;\n    this[_m] = m;\n    this[_n] = n;\n    return this;\n  }\n  /**\n   * Retrieve the element at the ith row and jth column.\n   *\n   * @param {number} i s.t. 0 <= i < m\n   * @param {number} j s.t. 0 <= i < n\n   * @return {number} Element at (i, j)\n   */\n\n\n  _createClass(Matrix, [{\n    key: \"get\",\n    value: function get(i, j) {\n      return this[_data][i * this[_n] + j];\n    }\n    /**\n     * Set the element at the ith row and jth column.\n     *\n     * @param {number} i s.t. 0 <= i < m\n     * @param {number} j s.t. 0 <= i < n\n     * @param {number} value To replace the existing one\n     * @return {number} Element at (i, j)\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(i, j, value) {\n      return this[_data][i * this[_n] + j] = value;\n    }\n    /**\n     * Performs element-wise addition between two matrices and returns a new copy.\n     *\n     * @param {number | Matrix<m,n>} other  Scalar or Matrix with equivalent\n     *                                      dimensions to this\n     * @return {Matrix<m,n>} this + other\n     * @throws {Error} If dimensions do not match\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      var sum = this.clone(),\n          i;\n\n      if (typeof other === 'number') {\n        for (i = 0; i < sum[_data].length; i += 1) {\n          sum[_data][i] += other;\n        }\n      } else {\n        if (this[_m] !== other[_m] || this[_n] !== other[_n]) {\n          throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_n] + ' !== ' + other[_m] + ' && ' + this[_m] + ' !== ' + other[_m]);\n        }\n\n        for (i = 0; i < sum[_data].length; i += 1) {\n          sum[_data][i] += other[_data][i];\n        }\n      }\n\n      return sum;\n    }\n    /**\n     * Performs element-wise subtraction between two matrices and returns a new\n     * copy.\n     *\n     * @param {number | Matrix<m,n>} other  Scalar or Matrix with equivalent\n     *                                      dimensions to this\n     * @return {Matrix<m,n>} this - other\n     * @throws {Error} If dimensions do not match\n     */\n\n  }, {\n    key: \"sub\",\n    value: function sub(other) {\n      var sum = this.clone(),\n          i;\n\n      if (typeof other === 'number') {\n        for (i = 0; i < sum[_data].length; i += 1) {\n          sum[_data][i] -= other;\n        }\n      } else {\n        if (this[_m] !== other[_m] || this[_n] !== other[_n]) {\n          throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_n] + ' !== ' + other[_m] + ' && ' + this[_m] + ' !== ' + other[_m]);\n        }\n\n        for (i = 0; i < sum[_data].length; i += 1) {\n          sum[_data][i] -= other[_data][i];\n        }\n      }\n\n      return sum;\n    }\n    /**\n     * Performs matrix multiplication between this and other.\n     *\n     * @param {Matrix<n,k>} other Matrix whose rows must be === to this's columns\n     * @return {Matrix<m,k>} this * other\n     * @throws {Error} If dimensions do not match\n     */\n\n  }, {\n    key: \"dot\",\n    value: function dot(other) {\n      if (this[_n] !== other[_m]) {\n        throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_n] + ' !== ' + other[_m]);\n      }\n\n      var product = new Matrix(this[_m], other[_n]),\n          i,\n          j,\n          k,\n          sum;\n\n      for (i = 0; i < this[_m]; i += 1) {\n        for (j = 0; j < other[_n]; j += 1) {\n          for (k = 0, sum = 0; k < this[_n]; k += 1) {\n            sum += this[_data][i * this[_n] + k] * other[_data][k * other[_n] + j];\n          }\n\n          product[_data][i * other[_n] + j] = sum;\n        }\n      }\n\n      return product;\n    }\n    /**\n     * Computes the inverse of the matrix (only if it is square!).\n     *\n     * @return {Matrix<m,n>} Inverse matrix s.t. this * inv(this) === I\n     * @throws {Error} If not a square matrix\n     */\n\n  }, {\n    key: \"inv\",\n    value: function inv() {\n      if (this[_m] !== this[_n]) {\n        throw new Error('Must be square');\n      }\n\n      var self = this.clone(),\n          inverse = Matrix.eye(this[_m], this[_n]),\n          i,\n          j,\n          k,\n          factor;\n\n      for (i = 0, j = 0; i < self[_m] && j < self[_n]; i += 1, j += 1) {\n        if (self[_data] === 0) {\n          for (k = 0; self[_data][k * self[_n] + j] !== 0 && k < self[_m]; k += 1) {\n            ;\n          }\n\n          if (k >= self[_m]) {\n            j += 1;\n            continue;\n          }\n\n          swapRows(self, j, k);\n          swapRows(inverse, j, k);\n        }\n\n        divideRow(self, inverse, j, self[_data][j * self[_n] + j]);\n        subtractRowMultiple(self, inverse, i, j);\n      }\n\n      return inverse;\n    }\n    /**\n     * Returns a copy of the matrix.\n     *\n     * @return {Matrix<m,n>} Fresh clone\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Matrix(this[_m], this[_n], this[_data].slice());\n    }\n    /**\n     * Horizontally stacks `other` and returns the new matrix.\n     *\n     * @param {Matrix<m,k>} other Matrix whose rows === this's rows\n     * @return {Matrix<m,n+k>} Horizontal concatenation of this and other\n     * @throws {Error} If dimensions do not match\n     */\n\n  }, {\n    key: \"hstack\",\n    value: function hstack(other) {\n      if (this[_m] !== other[_m]) {\n        throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_m] + ' !== ' + other[_m]);\n      }\n\n      var newM = this[_n] + other[_n],\n          stacked = new Matrix(this[_m], newM),\n          i,\n          j;\n\n      for (i = 0; i < this[_m]; i += 1) {\n        for (j = 0; j < this[_n]; j += 1) {\n          stacked[_data][i * newM + j] = this[_data][i * this[_n] + j];\n        }\n\n        for (j = 0; j < other[_n]; j += 1) {\n          stacked[_data][i * newM + this[_n] + j] = other[_data][i * other[_n] + j];\n        }\n      }\n\n      return stacked;\n    }\n    /**\n     * Vertically stacks `other` and returns the new matrix.\n     *\n     * @param {Matrix<k,n>} other Matrix whose cols === this's cols\n     * @return {Matrix<m+k,n>} Vertical concatenation of this and other\n     * @throws {Error} If dimensions do not match\n     */\n\n  }, {\n    key: \"vstack\",\n    value: function vstack(other) {\n      if (this[_n] !== other[_n]) {\n        throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_n] + ' !== ' + other[_n]);\n      }\n\n      var stacked = new Matrix(this[_m] + other[_m], this[_n]);\n\n      stacked[_data].subarray(0, this[_m] * this[_n]).set(this[_data]);\n\n      stacked[_data].subarray(this[_m] * this[_n]).set(other[_data]);\n\n      return stacked;\n    }\n    /**\n     * Performs element-wise exponentiation to the matrix and returns a new copy.\n     *\n     * @param {number} exponent Power to raise each element to\n     * @return {Matrix<m,n>} this[i,i]^exponent\n     */\n\n  }, {\n    key: \"dotPow\",\n    value: function dotPow(exponent) {\n      var powd = this.clone(),\n          i;\n\n      for (i = 0; i < powd[_data].length; i += 1) {\n        powd[_data][i] = Math.pow(powd[_data][i], exponent);\n\n        if (!Number.isFinite(powd[_data][i])) {\n          powd[_data][i] = MAX_SAFE_INTEGER;\n        }\n      }\n\n      return powd;\n    }\n    /**\n     * Performs element-wise multiplication to the matrix and returns a new copy.\n     *\n     * @param {number | Matrix} n Multiplicand to multiply each element by, or a\n     *                            matrix whose elements will be iterated through\n     *                            in alignment with this\n     * @return {Matrix<m,n>} this[i,i] * n   OR   this[i,i] * n[i,i]\n     */\n\n  }, {\n    key: \"dotMultiply\",\n    value: function dotMultiply(n) {\n      var product = this.clone(),\n          i;\n\n      if (typeof n === 'number') {\n        for (i = 0; i < product[_data].length; i += 1) {\n          product[_data][i] = product[_data][i] * n;\n        }\n      } else if (n instanceof Matrix) {\n        for (i = 0; i < product[_data].length; i += 1) {\n          product[_data][i] = product[_data][i] * n[_data][i];\n        }\n      }\n\n      return product;\n    }\n    /**\n     * Performs element-wise division to the matrix and returns a new copy.\n     *\n     * @param {number | Matrix} n Divisor to divide each element by, or a matrix\n     *                            whose elements will be iterated through in\n     *                            alignment with this\n     * @return {Matrix<m,n>} this[i,i] / n   OR   this[i,i] / n[i,i]\n     */\n\n  }, {\n    key: \"dotDivide\",\n    value: function dotDivide(n) {\n      var product = this.clone(),\n          i,\n          j;\n\n      if (typeof n === 'number') {\n        for (i = 0; i < product[_data].length; i += 1) {\n          product[_data][i] = product[_data][i] / n;\n        }\n      } else if (n instanceof Matrix) {\n        for (i = 0, j = 0; i < product[_data].length; i += 1, j += 1) {\n          if (j >= n[_data].length) {\n            j = 0;\n          }\n\n          product[_data][i] = product[_data][i] / n[_data][j];\n        }\n      }\n\n      return product;\n    }\n  }, {\n    key: \"log\",\n    value: function log() {\n      var product = this.clone(),\n          i;\n\n      for (i = 0; i < product[_data].length; i += 1) {\n        product[_data][i] = Math.log10(product[_data][i]);\n      }\n\n      return product;\n    }\n  }, {\n    key: \"appendM\",\n    value: function appendM(m) {\n      var matrix_dim = m.shape,\n          rows = this[_m],\n          cols = this[_n] + matrix_dim[1],\n          append_matrix = new Matrix(rows, cols),\n          i,\n          j;\n\n      for (i = 0; i < rows; i += 1) {\n        for (j = 0; j < cols; j += 1) {\n          var use_m = j - this[_n];\n          var data_pt = use_m >= 0 ? m[_data][i * matrix_dim[1] + use_m] : this[_data][i * this[_n] + j];\n          append_matrix[_data][i * cols + j] = data_pt;\n        }\n      }\n\n      return append_matrix;\n    }\n    /**\n     * @see inspect\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.inspect();\n    }\n    /**\n     * Converts to nested array format\n     *\n     * @return {[][]} Nested arrays, where each child array is a row\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var i, rows;\n\n      for (i = 1, rows = []; i <= this[_m]; i += 1) {\n        rows.push(Array.from(this[_data].slice((i - 1) * this[_n], i * this[_n])));\n      }\n\n      return rows;\n    }\n    /**\n     * Stringifies the matrix into a pretty format\n     *\n     * @return {string} Representation of the matrix\n     */\n\n  }, {\n    key: \"inspect\",\n    value: function inspect(depth) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        stylize: function stylize(x) {\n          return '' + x;\n        }\n      };\n      var repr = options.stylize(this.constructor.name, 'none'),\n          strings = Array.from(this[_data]).map(function (i) {\n        return ('' + i).match(/(NaN|-?Infinity|-?\\d*)\\.?(\\d*)/);\n      }),\n          lwidth = Math.max.apply(null, strings.map(function (match) {\n        return match[1].length;\n      })),\n          rwidth = Math.min(Math.max.apply(null, strings.map(function (match) {\n        return match[2].length;\n      })), PRINT_DECIMALS),\n          rows = [],\n          i;\n      strings = Array.from(this[_data]).map(function (n) {\n        return options.stylize(utils.formatNum(lwidth, rwidth, n), 'number');\n      });\n\n      for (i = 0; i < this[_m]; i += 1) {\n        rows.push('[ ' + strings.slice(i * this[_n], (i + 1) * this[_n]).join(', ') + ' ]');\n      }\n\n      return repr + ' ' + utils.padAll(this.constructor.name.length + 1, rows.join('\\n')).trim();\n    }\n    /**\n     * Retrieves/sets the ith column of the matrix\n     *\n     * @param {number}    i         Column index\n     * @param {number[]}  [newCol]  Elements to replace the col with\n     * @return {Matrix<m,1>} Column as a matrix\n     */\n\n  }, {\n    key: \"col\",\n    value: function col(i, newCol) {\n      var theCol = new Matrix(this[_m], 1),\n          k;\n\n      if (newCol != null) {\n        if (newCol.length > this[_m]) {\n          throw new RangeError('newCol cannot be longer than ' + this[_m]);\n        }\n\n        for (k = 0; k < this[_m]; k += 1) {\n          this[_data][k * this[_n] + i] = newCol[k];\n        }\n      }\n\n      for (k = 0; k < this[_m]; k += 1) {\n        theCol[_data][k] = this[_data][k * this[_n] + i];\n      }\n\n      return theCol;\n    }\n    /**\n     * Retrieves/sets the ith row of the matrix\n     *\n     * @param {number}    i         Row index\n     * @param {number[]}  [newRow]  Elements to replace the row with\n     * @return {Matrix<1,n>} Row as a matrix\n     */\n\n  }, {\n    key: \"row\",\n    value: function row(i, newRow) {\n      if (newRow != null) {\n        if (newRow.length > this[_n]) {\n          throw new RangeError('newRow cannot be longer than ' + this[_n]);\n        }\n\n        this[_data].subarray(i * this[_n]).set(newRow);\n      }\n\n      return new Matrix(1, this[_n], this[_data].slice(i * this[_n], (i + 1) * this[_n]));\n    }\n    /**\n     * Retrieves a subset of the matrix, constructed from indices in `rows` and\n     * `cols`. The resulting matrix will have rows s.t. result[i] = this[rows[i]]\n     * and columns s.t. result[i][j] = this[rows[i][cols[j]]]\n     *\n     * @param {number[]} rows Array of indices used to construct the subset\n     * @param {number[]} cols Array of indices used to construct the subset\n     * @return {Matrix<rows.length, cols.length>} Subset of this\n     */\n\n  }, {\n    key: \"subset\",\n    value: function subset() {\n      var rows = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ':';\n      var cols = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ':';\n      rows = utils.convertRange(rows, this[_m]);\n      cols = utils.convertRange(cols, this[_n]);\n      var subMatrix = new Matrix(rows.length, cols.length),\n          i,\n          j;\n\n      for (i = 0; i < rows.length; i += 1) {\n        for (j = 0; j < cols.length; j += 1) {\n          subMatrix[_data][i * subMatrix[_n] + j] = this[_data][rows[i] * this[_n] + cols[j]];\n        }\n      }\n\n      return subMatrix;\n    } // Create subset of data with row-end\n\n  }, {\n    key: \"lo\",\n    value: function lo() {\n      var row = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return new Matrix(this[_m] - row, this[_n], this[_data].slice(row * this[_n]));\n    } // Create a subset of data withs rows 0-row\n\n  }, {\n    key: \"hi\",\n    value: function hi() {\n      var row = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return new Matrix(row, this[_n], this[_data].slice(0, row * this[_n]));\n    } // Function removes column from matrix\n\n  }, {\n    key: \"delColumn\",\n    value: function delColumn() {\n      var col = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var columns = this[_n];\n      return new Matrix(this[_m], this[_n] - 1, this[_data].filter(function (_, i) {\n        return i % columns !== col;\n      }));\n    } // TODO: document\n\n  }, {\n    key: \"shift\",\n    value: function shift(rows) {\n      var newData = new Float64Array(this[_m] * this[_n]);\n      newData.subarray(this[_n] * rows).set(this[_data].subarray(0, -(this[_n] * rows) || this[_data].length));\n      return new Matrix(this[_n], this[_m], newData);\n    }\n    /**\n     * Retrieves the diagonal elements as a 1 x min(m, n) matrix.\n     *\n     * @return {Matrix<1,min(m,n)>} Diagonal elements\n     */\n\n  }, {\n    key: \"diag\",\n    value: function diag() {\n      var diagonal = new Matrix(1, Math.min(this[_m], this[_n])),\n          i;\n\n      for (i = 0; i < this[_m] && i < this[_n]; i += 1) {\n        diagonal[_data][i] = this[_data][i * this[_n] + i];\n      }\n\n      return diagonal;\n    }\n    /**\n     * Performs `Math.abs()` on each element then returns the resulting matrix.\n     *\n     * @return {Matrix<m,n>} A clone of `this`, but with the absolute value of\n     *                       each element\n     */\n\n  }, {\n    key: \"abs\",\n    value: function abs() {\n      var absolute = this.clone(),\n          i;\n\n      for (i = 0; i < absolute[_data].length; i += 1) {\n        absolute[_data][i] = Math.abs(absolute[_data][i]);\n      }\n\n      return absolute;\n    }\n    /**\n     * Sums all of the elements.\n     *\n     * @return {number} Sum of all of the elements\n     */\n\n  }, {\n    key: \"sum\",\n    value: function sum() {\n      var tot = 0,\n          i;\n\n      for (i = 0; i < this[_data].length; i += 1) {\n        tot += this[_data][i];\n      }\n\n      return tot;\n    }\n    /**\n     * Takes the product of all elements.\n     *\n     * @return {number} Product of all elements\n     */\n\n  }, {\n    key: \"prod\",\n    value: function prod() {\n      var tot = 1,\n          i;\n\n      for (i = 0; i < this[_data].length; i += 1) {\n        tot *= this[_data][i];\n      }\n\n      return tot;\n    }\n    /**\n     * Get minimum value in matrix\n     *\n     * @return {number} Minimum value\n     */\n\n  }, {\n    key: \"min\",\n    value: function min() {\n      var i, min;\n\n      for (i = 0, min = Infinity; i < this[_data].length; i += 1) {\n        min = Math.min(min, this[_data][i]);\n      }\n\n      return min;\n    }\n    /**\n     * Get maximum value in matrix\n     *\n     * @return {number} Maximum value\n     */\n\n  }, {\n    key: \"max\",\n    value: function max() {\n      var i, max;\n\n      for (i = 0, max = -Infinity; i < this[_data].length; i += 1) {\n        max = Math.max(max, this[_data][i]);\n      }\n\n      return max;\n    }\n    /**\n     * @property {Matrix<n,m>} T The transposition of the matrix\n     */\n\n  }, {\n    key: \"T\",\n    get: function get() {\n      var transpose = new Matrix(this[_n], this[_m]),\n          i,\n          j;\n\n      for (i = 0; i < this[_m]; i += 1) {\n        for (j = 0; j < this[_n]; j += 1) {\n          transpose[_data][j * this[_m] + i] = this[_data][i * this[_n] + j];\n        }\n      }\n\n      return transpose;\n    }\n    /**\n     * @property {[number, number]} shape The shape of this matrix [m, n]\n     */\n\n  }, {\n    key: \"shape\",\n    get: function get() {\n      return [this[_m], this[_n]];\n    }\n    /**\n     * @property {Float64Array} data The underlying storage for the matrix\n     */\n\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this[_data];\n    }\n    /**\n     * Generates a matrix full of random (0, 1) numbers.\n     *\n     * @static\n     * @return {Matrix<m,n>} Matrix full'a random numbas\n     */\n\n  }], [{\n    key: \"random\",\n    value: function random(m, n) {\n      var randMatrix = new Matrix(m, n),\n          i,\n          j;\n\n      for (i = 0; i < m; i += 1) {\n        for (j = 0; j < n; j += 1) {\n          randMatrix[_data][i * n + j] = Math.random();\n        }\n      }\n\n      return randMatrix;\n    }\n    /**\n     * Generates a matrix whose diagonal elements equal 1.\n     *\n     * @static\n     * @return {Matrix<m,n>} Diagonal onez\n     */\n\n  }, {\n    key: \"eye\",\n    value: function eye(m) {\n      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : m;\n      var onez = new Matrix(m, n),\n          i,\n          j;\n\n      for (i = 0; i < m; i += 1) {\n        onez[_data][i * n + i] = 1;\n      }\n\n      return onez;\n    }\n    /**\n     * Creates a matrix from matrix-looking nested arrays, or a flat array and the\n     * given `m` and `n`.\n     *\n     * @param {iterable | Matrix} arr Values to populate the matrix with\n     * @param {number}            m   Rows in the new matrix\n     * @param {number}            n   Columns in the new matrix\n     */\n\n  }, {\n    key: \"from\",\n    value: function from(arr, m, n) {\n      if (arr instanceof Matrix) {\n        return arr.clone();\n      }\n\n      if (!Array.isArray(arr)) {\n        throw new TypeError('Expected an array or Matrix');\n      }\n\n      if (arr.length <= 0) {\n        return new Matrix(0, 0);\n      }\n\n      var i;\n      m = m || arr.length;\n      n = n || arr[0].length; // handed a 1-d array\n\n      if (arr[0].length == null) {\n        return new Matrix(1, arr.length, Float64Array.from(arr));\n      } // otherwise, it's a 2-d array (and hopefully not >2-d)\n\n\n      for (i = 0; i < arr.length; i += 1) {\n        if (arr[i].length !== n) {\n          throw new Error('All rows must have equal length');\n        }\n      }\n\n      return new Matrix(m, n, Float64Array.from(utils.join(arr)));\n    }\n    /**\n     * Creates a matrix using `arr` to fill the diagonal elements in order.\n     *\n     * @param {number[m]} arr Array of numbers\n     * @returns {Matrix<m,m>} Matrix consisting only of the diagonal elements\n     */\n\n  }, {\n    key: \"diag\",\n    value: function diag(arr) {\n      var m = arr.length,\n          mat = new Matrix(m, m),\n          i;\n\n      for (i = 0; i < m; i += 1) {\n        mat.data[i * m + i] = arr[i];\n      }\n\n      return mat;\n    }\n  }, {\n    key: \"zeros\",\n    value: function zeros(m) {\n      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : m;\n      return this.eye(m, n).dotMultiply(0);\n    }\n  }]);\n\n  return Matrix;\n}();\n\nmodule.exports = Matrix;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/matrix/Matrix.js\n// module id = 204\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/matrix/Matrix.js?")},205:/*!************************************!*\
  !*** ./engine/regression/lstsq.js ***!
  \************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){"use strict";eval("\n\nvar Matrix = __webpack_require__(/*! ../matrix */ 79);\n\nvar svd = __webpack_require__(/*! ./svd-golub-reinsch */ 139);\n\nvar statistics = __webpack_require__(/*! ../statistics */ 121);\n\nvar dist = __webpack_require__(/*! ../statistics/distributions-socr */ 141);\n\nvar utils = __webpack_require__(/*! ../utils */ 78);\n/**\n * Computes total least squares regression on the matrix `A`, already decomposed\n * using SVD into the constituent `U`, `S` (sigma), and `V` matrices.\n *\n * @param {Matrix<m,n>} A Data matrix\n * @param {Matrix<m,m>} U U matrix resulting from SVD\n * @param {Matrix<m,n>} S Diagonal sigma matrix resulting from SVD\n * @param {Matrix<n,n>} V V matrix resulting from SVD\n * @param {Matrix<m,1>} b Independent column\n * @return {Matrix<n,1>} Estimated weight vector for the parameters (cols) in A\n */\n\n\nfunction lstsqSVD(A, U, S, V, b) {\n  var s = S,\n      m = A.shape[0],\n      n = A.shape[1],\n      eps = Number.EPSILON,\n      efcols = [],\n      maxEig = Math.max.apply(null, s.data),\n      i,\n      d,\n      x;\n\n  for (i = 0; i < n; i++) {\n    if (s.data[i] < Math.max(m, n) * eps * maxEig) {\n      s.data[i] = 0;\n    }\n  }\n\n  d = U.T.dot(b);\n  d = d.dotDivide(s);\n\n  for (i = 0; i < n; i++) {\n    if (Math.abs(d.data[i]) === Infinity) {\n      d.data[i] = 0;\n    }\n  }\n\n  x = V.dot(d);\n  return x;\n}\n/**\n * Compute least squares regression using normal equations, then compute\n * analytical statistics to determine the quality of the fit for the model and\n * for each term in the model.\n *\n *    B'      = inv(X'X)X'y                       <-- weight vector\n *    y'      = XB'\n *\n *    Nd      = # of data\n *    Np      = # of params (coefs) in model\n *\n *    SSE     = sum((y - y')^2)                   ^2 is element-wise\n *    TSS     = sum((y - mean(y))^2)\n *    SSR     = TSS - SSE\n *    Var y   = TSS / (Nd - 1)\n *    MSR     = SSR / (Np - 1)\n *    MSE     = SSE / (Nd - Np)\n *    RSQ     = 1 - (SSE / TSS)\n *    cRSQ    = 1 - R^2\n *    adj-RSQ = 1 - (MSE / Var y)\n *    F       = MSR / MSE\n *    AIC     = log(MSE) + 2*(Np/Nd)\n *    BIC     = log(MSE) + Np*log(Nd)/Nd\n *    t_i     = B' / sqrt( inv(X'X)[i,i] * MSE )   / is element-wise\n *    SKEW    = sum((y-y')^3/N/s^3)\n *    XKURT    = sum((y-y')^4/N/s^4)\n *\n * @return {object} Regression results\n */\n\n\nfunction lstsqNEWithStats(X, y) {\n  var XT = X.T,\n      pseudoInverse = XT.dot(X).inv(),\n      BHat = pseudoInverse.dot(XT).dot(y),\n      yHat = X.dot(BHat) // fit statistics\n  ,\n      nd = X.shape[0],\n      np = X.shape[1],\n      sse = y.sub(yHat).dotPow(2).sum(),\n      tss = y.sub(y.sum() / y.shape[0]).dotPow(2).sum(),\n      ssr = tss - sse,\n      vary = tss / (nd - 1),\n      msr = ssr / (np - 1),\n      mse = sse / (nd - np),\n      rsq = 1 - sse / tss,\n      adjrsq = 1 - mse / vary,\n      f = msr / mse,\n      aic = Math.log10(mse) + 2 * (np / nd),\n      bic = Math.log10(mse) + np * (Math.log10(nd) / nd) // for t-statistics\n  ,\n      rtmse = Math.sqrt(mse),\n      sec = pseudoInverse.diag().abs().dotPow(0.5).dotMultiply(rtmse),\n      tstats = BHat.dotDivide(sec),\n      pts = tstats.clone();\n  pts.data.set(pts.data.map(function (t) {\n    return dist.pt(t, nd - np);\n  }));\n  return {\n    weights: BHat,\n    tstats: tstats,\n    mse: mse,\n    rsq: rsq,\n    adjrsq: adjrsq,\n    f: f,\n    pf: dist.pf(f, np, nd - np),\n    aic: aic,\n    bic: bic,\n    pts: pts\n  };\n}\n\nfunction scale(X) {\n  var stdevs = [];\n  var means = [];\n  var intercept = -1;\n  var i;\n\n  for (i = 0; i < X.shape[1]; i += 1) {\n    var col = X.col(i);\n    var nd = col.shape[0];\n    var mean = col.sum() / nd;\n    var newCol = col.sub(mean);\n    var stdev = Math.sqrt(newCol.dotPow(2).sum() / (nd - 1));\n    means.push(mean);\n\n    if (stdev <= Number.EPSILON && mean === 1) {\n      stdevs.push(1);\n      intercept = i;\n    } else {\n      X.col(i, newCol.dotDivide(stdev).data);\n      stdevs.push(stdev);\n    }\n  }\n\n  return {\n    stdev: new Matrix(stdevs).T,\n    mean: new Matrix(means).T,\n    intercept: intercept\n  };\n}\n/**\n * Compute least squares regression using singular value decomposition, then\n * compute analytical statistics to determine the quality of the fit for the\n * model and for each term in the model.\n *\n *    U, s, V = svd(X)\n *    B'      = V(U'b ./ s)                       See svd.lstsq for more\n *    y'      = XB'\n *\n * @return {object} Regression results\n */\n\n\nfunction lstsqSVDWithStats(X, y, predictors) {\n  var i;\n  var stdev = 1,\n      mean = 0,\n      intercept = -1; //let { stdev, mean, intercept } = scale(X);\n\n  var decomposition = svd(X),\n      U = decomposition[0],\n      w = Matrix.from(decomposition[1]),\n      V = decomposition[2],\n      VdivwSq = V.dotDivide(w).dotPow(2),\n      BHat = predictors || lstsqSVD(X, U, w, V, y),\n      weights = BHat.dotDivide(stdev); // If there is an intercept, un-scale its weight by subtracting the means of\n  // the other columns times the corresponding sign of their weights\n  //\n  //          B_0 = B_0 - sum(mean(i) * sign(weights(i)))\n  //\n\n  if (intercept >= 0) {\n    var interceptWeight = weights.get(0, intercept) + 1;\n\n    for (i = 0; i < weights.shape[0]; i += 1) {\n      interceptWeight -= mean.data[i] * utils.sign(weights.data[i]);\n    }\n\n    weights.data[intercept] = interceptWeight;\n  } // Remove infinitely high values to work around potential divide-by-zero issue\n\n\n  for (i = 0; i < VdivwSq.data.length; i += 1) {\n    if (Math.abs(VdivwSq.data[i]) === Infinity || isNaN(VdivwSq.data[i])) {\n      VdivwSq.data[i] = 0;\n    }\n  }\n\n  return {\n    X: X,\n    y: y,\n    BHat: BHat,\n    VdivwSq: VdivwSq,\n    stdev: stdev,\n    mean: mean,\n    weights: weights,\n    V: V,\n    w: w\n  };\n}\n\nmodule.exports.lstsqSVD = lstsqSVDWithStats;\nmodule.exports.lstsqNE = lstsqNEWithStats;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/regression/lstsq.js\n// module id = 205\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/regression/lstsq.js?")},206:/*!**************************************!*\
  !*** ./engine/statistics/topsort.js ***!
  \**************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports){eval("var inDegree = function inDegree(stat, statistics) {\n  var names = statistics.map(function (_ref) {\n    var name = _ref.name;\n    return name;\n  });\n  return stat.args.filter(function (s) {\n    return names.includes(s);\n  }).length;\n};\n\nvar topsort = function topsort(statistics) {\n  var S = statistics.filter(function (stat) {\n    return stat.args.length === 0;\n  });\n  var L = [];\n  var remaining = statistics.filter(function (stat) {\n    return !S.includes(stat);\n  });\n  var node;\n\n  while (S.length > 0) {\n    node = S.shift();\n    remaining = remaining.filter(function (n) {\n      return n !== node;\n    });\n    L.push(node);\n    S = S.concat(remaining.filter(function (stat) {\n      return inDegree(stat, remaining) === 0;\n    }));\n    remaining = remaining.filter(function (stat) {\n      return !S.includes(stat);\n    });\n  }\n\n  if (remaining.length > 0) {\n    throw new Error('Statistics are co-dependent');\n  }\n\n  return L;\n};\n\nmodule.exports = topsort;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/topsort.js\n// module id = 206\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/topsort.js?")},207:/*!******************************************!*\
  !*** ./engine/statistics/definitions.js ***!
  \******************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){eval("var Statistic = __webpack_require__(/*! ./Statistic */ 140);\n\nvar Matrix = __webpack_require__(/*! ../matrix */ 79);\n\nvar dist = __webpack_require__(/*! ./distributions-socr */ 141); // Functional definitions for statistics -- defines how they will be calculated\n// NOTE: Make sure each statistic has an entry in `metadata.json`\n\n\nmodule.exports = [// given\nStatistic('X', [], function (_ref) {\n  var X = _ref.X;\n  return X;\n}), Statistic('y', [], function (_ref2) {\n  var y = _ref2.y;\n  return y;\n}), Statistic('BHat', [], function (_ref3) {\n  var BHat = _ref3.BHat;\n  return BHat;\n}), Statistic('yHat', ['X', 'BHat'], function (_ref4) {\n  var X = _ref4.X,\n      BHat = _ref4.BHat;\n  return X.dot(BHat);\n}), // fit statistics\nStatistic('nd', ['X'], function (_ref5) {\n  var X = _ref5.X;\n  return X.shape[0];\n}), Statistic('np', ['X'], function (_ref6) {\n  var X = _ref6.X;\n  return X.shape[1];\n}), Statistic('SSE', ['y', 'yHat'], function (_ref7) {\n  var y = _ref7.y,\n      yHat = _ref7.yHat;\n  return y.sub(yHat).dotPow(2).sum();\n}), Statistic('TSS', ['y'], function (_ref8) {\n  var y = _ref8.y;\n  return y.sub(y.sum() / y.shape[0]).dotPow(2).sum();\n}), // yHat.sub(y.sum() / y.shape[0]).dotPow(2).sum()));\nStatistic('SSR', ['TSS', 'SSE'], function (_ref9) {\n  var TSS = _ref9.TSS,\n      SSE = _ref9.SSE;\n  return TSS - SSE;\n}), Statistic('Vary', ['TSS', 'nd'], function (_ref10) {\n  var TSS = _ref10.TSS,\n      nd = _ref10.nd;\n  return TSS / (nd - 1);\n}), Statistic('MSR', ['SSR', 'np'], function (_ref11) {\n  var SSR = _ref11.SSR,\n      np = _ref11.np;\n  return SSR / (np - 1);\n}), Statistic('SKEW', ['y', 'yHat', 'nd'], function (_ref12) {\n  var y = _ref12.y,\n      yHat = _ref12.yHat,\n      nd = _ref12.nd;\n  var residuals = y.sub(yHat);\n  var residMean = residuals.sum() / residuals.shape[0];\n  var residStDv = Math.sqrt(residuals.sub(residMean).dotPow(2).sum() / (nd - 1));\n  return nd * residuals.sub(residMean).dotPow(3).sum() / (nd - 1) / (nd - 2) / residStDv / residStDv / residStDv;\n}), Statistic('XKURT', ['y', 'yHat', 'nd'], function (_ref13) {\n  var y = _ref13.y,\n      yHat = _ref13.yHat,\n      nd = _ref13.nd;\n  var residuals = y.sub(yHat);\n  var residMean = residuals.sum() / residuals.shape[0];\n  var residStDv = Math.sqrt(residuals.sub(residMean).dotPow(2).sum() / (nd - 1)); // let r1 =  nd * (nd + 1) *residuals.sub(residMean).dotPow(4).sum() / (nd - 1) / (nd - 2) / (nd - 3) / residStDev / residStDv / residStDv / residStdDv;\n\n  var r1 = nd * (nd + 1) * residuals.sub(residMean).dotPow(4).sum() / (nd - 1) / (nd - 2) / (nd - 3) / residStDv / residStDv / residStDv / residStDv;\n  var r2 = 3 * (nd - 1) * (nd - 1) / (nd - 2) / (nd - 3);\n  return r1 - r2;\n}), Statistic('seSKEW', ['nd'], function (_ref14) {\n  var nd = _ref14.nd;\n  return Math.sqrt(6 / nd);\n}), Statistic('seXKURT', ['nd'], function (_ref15) {\n  var nd = _ref15.nd;\n  return Math.sqrt(24 / nd);\n}), Statistic('MSE', ['SSE', 'nd', 'np'], function (_ref16) {\n  var SSE = _ref16.SSE,\n      nd = _ref16.nd,\n      np = _ref16.np;\n  return SSE / (nd - np);\n}), Statistic('RMSE', ['MSE'], function (_ref17) {\n  var MSE = _ref17.MSE;\n  return Math.sqrt(MSE);\n}), Statistic('Rsq', ['SSE', 'TSS'], function (_ref18) {\n  var SSE = _ref18.SSE,\n      TSS = _ref18.TSS;\n  return 1 - SSE / TSS;\n}), Statistic('adjRsq', ['Rsq', 'np', 'nd'], function (_ref19) {\n  var Rsq = _ref19.Rsq,\n      nd = _ref19.nd,\n      np = _ref19.np;\n  return 1 - (1 - Rsq) * (nd - 1) / (nd - np);\n}), Statistic('F', ['MSR', 'MSE'], function (_ref20) {\n  var MSR = _ref20.MSR,\n      MSE = _ref20.MSE;\n  return MSR / MSE;\n}), Statistic('AIC', ['MSE', 'np', 'nd'], function (_ref21) {\n  var MSE = _ref21.MSE,\n      np = _ref21.np,\n      nd = _ref21.nd;\n  return Math.log10(MSE) + 2 * (np / nd);\n}), Statistic('BIC', ['MSE', 'np', 'nd'], function (_ref22) {\n  var MSE = _ref22.MSE,\n      np = _ref22.np,\n      nd = _ref22.nd;\n  return Math.log10(MSE) + np * (Math.log10(nd) / nd);\n}), Statistic('MaxAbsErr', ['y', 'yHat'], function (_ref23) {\n  var y = _ref23.y,\n      yHat = _ref23.yHat;\n  return y.sub(yHat).abs().max();\n}), Statistic('t', ['X', 'VdivwSq', 'MSE', 'BHat'], function (_ref24) {\n  var X = _ref24.X,\n      VdivwSq = _ref24.VdivwSq,\n      MSE = _ref24.MSE,\n      BHat = _ref24.BHat;\n  var sec = new Matrix(1, X.shape[1]),\n      stdModelErr,\n      i;\n\n  for (i = 0; i < X.shape[1]; i += 1) {\n    stdModelErr = Math.sqrt(VdivwSq.row(i).sum() * MSE);\n    sec.data[i] = stdModelErr;\n  }\n\n  return BHat.dotDivide(sec);\n}), Statistic('pt', ['t', 'np', 'nd'], function (_ref25) {\n  var t = _ref25.t,\n      np = _ref25.np,\n      nd = _ref25.nd;\n  var pt = t.clone();\n  pt.data.set(pt.data.map(function (t) {\n    return Math.max(0, dist.pt(t, nd - np));\n  }));\n  return pt;\n}), Statistic('pF', ['F', 'np', 'nd'], function (_ref26) {\n  var F = _ref26.F,\n      np = _ref26.np,\n      nd = _ref26.nd;\n  return Math.max(dist.pf(Math.abs(F), np, nd - np) - 1e-15, 0);\n}), Statistic('log', [\"X\"], function (_ref27) {\n  var X = _ref27.X;\n  return X.log();\n}), Statistic('mean', [\"X\"], function (_ref28) {\n  var X = _ref28.X;\n  return X.data.reduce(function (total, c) {\n    return total += c;\n  }, 0) / X.data.length;\n}), Statistic('std', [\"X\", \"mean\"], function (_ref29) {\n  var X = _ref29.X,\n      mean = _ref29.mean;\n  var diff = X.data.map(function (d) {\n    return Math.pow(d - mean, 2);\n  });\n  var diff_total = diff.reduce(function (total, c) {\n    return total += c;\n  }, 0);\n  return Math.sqrt(diff_total / X.data.length);\n}), Statistic('standardize', [\"X\", \"mean\", \"std\"], function (_ref30) {\n  var X = _ref30.X,\n      mean = _ref30.mean,\n      std = _ref30.std;\n  var standardize = X.clone();\n  standardize.data.set(standardize.data.map(function (d) {\n    return (d - mean) / std;\n  }));\n  return standardize;\n}), Statistic('RMS', [\"X\"], function (_ref31) {\n  var X = _ref31.X;\n  var rms = X.clone();\n  var SS = rms.data.map(function (r) {\n    return Math.pow(r, 2);\n  }).reduce(function (total, xi) {\n    return total += xi;\n  }, 0);\n  return Math.sqrt(SS / rms.data.length);\n}), Statistic('rescale', [\"X\", \"RMS\"], function (_ref32) {\n  var X = _ref32.X,\n      RMS = _ref32.RMS;\n  var rescale = X.clone();\n  rescale.data.set(rescale.data.map(function (d) {\n    return d / RMS;\n  }));\n  return rescale;\n}), Statistic('k_order_difference', [\"X\", \"k\"], function (_ref33) {\n  var X = _ref33.X,\n      k = _ref33.k;\n\n  var k_order_func = function k_order_func(data, k) {\n    if (k == 1) {\n      return data.map(function (d, idx) {\n        return idx < k ? null : d - data[idx - 1];\n      });\n    } else {\n      k_1_order = k_order_func(data, k - 1);\n      return data.map(function (_, idx) {\n        return idx < k ? null : k_1_order[idx] - k_1_order[idx - 1];\n      });\n    }\n  };\n\n  if (!k || isNaN(k)) {\n    return X;\n  }\n\n  var k_order = X.clone();\n  k_order.data.set(k_order_func(k_order.data, k));\n  return k_order;\n}), Statistic('sensitivity_part', ['data', 'exp', 'derivative'], function (_ref34) {\n  var data = _ref34.data,\n      exp = _ref34.exp,\n      derivative = _ref34.derivative;\n\n  if (data == undefined) {\n    return -1;\n  }\n\n  if (derivative) {\n    return data.map(function (x) {\n      return exp * Math.pow(x, exp - 1);\n    });\n  } else {\n    return data.map(function (x) {\n      return Math.pow(x, exp);\n    });\n  }\n})];\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/definitions.js\n// module id = 207\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/definitions.js?")},261:/*!************************************!*\
  !*** ./engine/model/CacheMixin.js ***!
  \************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar _cache = Symbol(\'cache\');\n\nvar _mixinref = Symbol(\'CacheMixin_ref\');\n\nvar CacheMixin = function CacheMixin() {\n  var superclass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /*#__PURE__*/function () {\n    function _class() {\n      _classCallCheck(this, _class);\n    }\n\n    return _class;\n  }();\n  return /*#__PURE__*/function (_superclass) {\n    _inherits(_class2, _superclass);\n\n    var _super = _createSuper(_class2);\n\n    function _class2() {\n      var _this;\n\n      _classCallCheck(this, _class2);\n\n      _this = _super.apply(this, arguments);\n      _this[_cache] = {};\n      return _this;\n    }\n\n    _createClass(_class2, [{\n      key: "uncache",\n      value: function uncache(functionName) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        var argsKey = args.toString();\n\n        if (functionName == null) {\n          this[_cache] = {};\n          return this;\n        }\n\n        if (this[_cache][functionName] == null) {\n          return this;\n        }\n\n        if (args.length <= 0) {\n          this[_cache][functionName] = {};\n          return this;\n        }\n\n        var _this$functionName = this[functionName],\n            defaultArgs = _this$functionName.defaultArgs,\n            originalLength = _this$functionName.originalLength;\n        args = args.concat(defaultArgs.slice(args.length));\n        args.length = originalLength + defaultArgs.length;\n        delete this[_cache][functionName][args.toString()];\n        return this;\n      }\n    }], [{\n      key: _mixinref,\n      get: function get() {\n        return true;\n      }\n    }]);\n\n    return _class2;\n  }(superclass);\n}; // Static function that should be used to specify functions to apply caching to\n\n\nCacheMixin.cache = function (clazz, functionName) {\n  var defaultArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var originalFunction = clazz.prototype[functionName];\n\n  if (clazz[_mixinref] !== true) {\n    throw new TypeError(\'Class must extend CacheMixin\');\n  }\n\n  if (originalFunction == null) {\n    throw new ReferenceError("".concat(clazz.name, ".prototype.").concat(functionName, " is not a function"));\n  } // Overwrite prototype definition with wrapper that caches results\n\n\n  clazz.prototype[functionName] = function () {\n    var args = Array.prototype.slice.apply(arguments).concat(defaultArgs.slice(arguments.length));\n    args.length = originalFunction.length + defaultArgs.length;\n    var argsKey = args.toString();\n\n    if (this[_cache][functionName] == null) {\n      this[_cache][functionName] = {};\n    }\n\n    if (argsKey in this[_cache][functionName]) {\n      return this[_cache][functionName][argsKey];\n    }\n\n    this[_cache][functionName][argsKey] = originalFunction.apply(this, args);\n    return this[_cache][functionName][argsKey];\n  }; // Expose default arguments and original function length for use later on\n\n\n  clazz.prototype[functionName].defaultArgs = defaultArgs;\n  clazz.prototype[functionName].originalLength = originalFunction.length;\n};\n\nmodule.exports = CacheMixin;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/CacheMixin.js\n// module id = 261\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/model/CacheMixin.js?')},388:/*!****************************************!*\
  !*** ./engine/worker/engine-worker.js ***!
  \****************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){"use strict";eval("/*global onmessage, postMessage*/\n\n\n__webpack_require__(/*! ./subworkers */ 108);\n\nvar perf = __webpack_require__(/*! ../perf */ 203);\n\nvar statsMeta = __webpack_require__(/*! ../statistics/metadata.json */ 168);\n\nvar Model = __webpack_require__(/*! ../model */ 389);\n\nvar _require = __webpack_require__(/*! ../labels.json */ 80),\n    FIT_LABEL = _require.FIT_LABEL,\n    CROSS_LABEL = _require.CROSS_LABEL,\n    VALIDATION_LABEL = _require.VALIDATION_LABEL,\n    LOG = _require.LOG,\n    K_ORDER_DIFFERENCE = _require.K_ORDER_DIFFERENCE,\n    STANDARDIZE = _require.STANDARDIZE,\n    RESCALE = _require.RESCALE,\n    DELETE = _require.DELETE;\n\nvar Transformation = __webpack_require__(/*! ../../interface/components/transform/label.json */ 122);\n\nvar getCandidateProgressInterval = 50;\nvar onGetCandidateId = 0;\nvar m = initializeModel();\n\nfunction log() {\n  var _console;\n\n  (_console = console).debug.apply(_console, ['[Engine]:'].concat(Array.prototype.slice.call(arguments)));\n}\n\n;\n\nfunction initializeModel() {\n  var m = new Model();\n  m.on('getCandidates.start', function () {\n    return postMessage({\n      type: 'progress.start',\n      data: {}\n    });\n  });\n  m.on('getCandidates.start', function () {\n    return perf.start('get-candidates');\n  });\n  m.on('getCandidates.end', function () {\n    perf.end('get-candidates');\n    perf.report('get-candidates', 3);\n  }); // Subscribe to progress changes\n\n  onGetCandidateId = m.on('getCandidates.each', function (data) {\n    if (data.curr % getCandidateProgressInterval === 0) {\n      postMessage({\n        type: 'progress',\n        data: {\n          curr: data.curr,\n          total: data.total\n        }\n      });\n    }\n  });\n  m.on('getCandidates.end', function () {\n    return postMessage({\n      type: 'progress.end',\n      data: {}\n    });\n  });\n  m.on(\"dataTransform\", function () {\n    postMessage({\n      type: \"data:transform\",\n      data: {\n        // This sets the data in the Model, but Model.coffee will not update, need to fire back to adapter new data\n        fit: m.getLabelData(FIT_LABEL) ? m.getLabelData(FIT_LABEL).toJSON() : undefined,\n        cross: m.getLabelData(CROSS_LABEL) ? m.getLabelData(CROSS_LABEL).toJSON() : undefined,\n        validation: m.getLabelData(VALIDATION_LABEL) ? m.getLabelData(VALIDATION_LABEL).toJSON() : undefined\n      }\n    });\n  });\n  m.on('propogateTransform', function (data) {\n    postMessage({\n      type: \"propogateTransform\",\n      data: {\n        data_label: data.data_label\n      }\n    });\n  });\n  m.on('error', function (error) {\n    return postMessage({\n      type: 'error',\n      data: error\n    });\n  });\n  m.on('getSensitivity', function (data) {\n    postMessage({\n      type: 'model:getSensitivity',\n      data: data\n    });\n  });\n  m.on('deleteSensitivity', function (data) {\n    postMessage({\n      type: 'model:deleteSensitivity',\n      data: data\n    });\n  });\n  m.on('updateSensitivity', function (data) {\n    postMessage({\n      type: 'model:updateSensitivity',\n      data: data\n    });\n  });\n  m.on('getImportanceRatio', function (data) {\n    postMessage({\n      type: 'model:getImportanceRatio',\n      data: data\n    });\n  });\n  m.on('deleteImportanceRatio', function (data) {\n    postMessage({\n      type: 'model:deleteImportanceRatio',\n      data: data\n    });\n  });\n  m.on('updateImportanceRatio', function (data) {\n    postMessage({\n      type: 'model:updateImportanceRatio',\n      data: data\n    });\n  });\n  return m;\n} // Whenever a parameter changes, let's update the UI\n\n\nvar subscriptionIds = [];\n\nvar subscribeToChanges = function subscribeToChanges(m) {\n  var updateNow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  m.removeListener(subscriptionIds);\n  subscriptionIds = m.on(['setData', 'setExponents', 'setMultiplicands', 'setDependent', 'setLags', 'addTerm', 'removeTerm', 'clear', 'subset', 'setColumns', 'getSensitivity', 'deleteSensitivity', 'updateSensitivity', 'getImportanceRatio', 'deleteImportanceRatio', 'updateImportanceRatio'], function () {\n    m.getCandidates().then(function (cands) {\n      return postMessage({\n        type: 'candidates',\n        data: cands\n      });\n    });\n    m.labels.forEach(function (label) {\n      return postMessage({\n        type: \"model:\".concat(label),\n        data: m.getModel(label)\n      });\n    });\n  });\n\n  if (updateNow) {\n    m.fire('setData');\n  }\n};\n\nvar unsubscribeToChanges = function unsubscribeToChanges(m) {\n  return m.removeListener(subscriptionIds);\n}; // By default, subscribe\n//subscribeToChanges(m, false);\n\n/**\n * Function calls off subscription handler from engine/model.js\n */\n\n\nonmessage = function onmessage(e) {\n  // If it's for a sub-worker, just ignore it\n  if (e.data._from != null) {\n    return;\n  }\n\n  var type = e.data.type,\n      data = e.data.data,\n      temp;\n  log(e.data);\n\n  switch (type) {\n    // only works because the event type is the same as the method name\n    case 'setExponents':\n    case 'setMultiplicands':\n    case 'setDependent':\n    case 'setColumns':\n    case 'setLags':\n    case 'addTerm':\n    case 'removeTerm':\n    case 'clear':\n      m[type](data);\n      break;\n    // this one's special\n\n    case 'setData':\n      m[type](data.data, data.label);\n      break;\n\n    case 'getTerms':\n      postMessage({\n        type: 'candidates',\n        data: m.getCandidates()\n      });\n      break;\n\n    case 'getStatisticsMetadata':\n      postMessage({\n        type: 'statisticsMetadata',\n        data: statsMeta\n      });\n      break;\n\n    case 'subscribeToChanges':\n      subscribeToChanges(m);\n      break;\n\n    case 'unsubscribeToChanges':\n      unsubscribeToChanges(m);\n      break;\n\n    case 'subset':\n      m.subset(data.label, data.start, data.end);\n      break;\n\n    case 'transformData':\n      switch (data.label) {\n        case Transformation.Transform[\"delete\"]:\n          m.transformColumn(DELETE, {\n            index: data.index,\n            data_labels: data.data_labels\n          });\n          break;\n\n        case Transformation.Transform.log:\n          m.transformColumn(LOG, {\n            index: data.index,\n            data_labels: data.data_labels\n          });\n          break;\n\n        case Transformation.Transform.k_order_diff:\n          m.transformColumn(K_ORDER_DIFFERENCE, {\n            index: data.index,\n            k: data.k,\n            data_labels: data.data_labels\n          });\n          break;\n\n        case Transformation.Transform.standardize:\n          m.transformColumn(STANDARDIZE, {\n            index: data.index,\n            data_labels: data.data_labels\n          });\n          break;\n\n        case Transformation.Transform.rescale:\n          m.transformColumn(RESCALE, {\n            index: data.index,\n            data_labels: data.data_labels\n          });\n          break;\n\n        default:\n          break;\n      }\n\n      break;\n\n    case 'getSensitivity':\n      m.getSensitivity(data);\n      break;\n\n    case 'deleteSensitivity':\n      m.deleteSensitivity(data);\n      break;\n\n    case 'updateSensitivity':\n      m.updateSensitivity(data);\n      break;\n\n    case 'getImportanceRatio':\n      m.getImportanceRatio(data);\n      break;\n\n    case 'deleteImportanceRatio':\n      m.deleteImportanceRatio(data);\n      break;\n\n    case 'updateImportanceRatio':\n      m.updateImportanceRatio(data);\n      break;\n\n    case 'reset':\n      m = new Model();\n      break;\n\n    default:\n      postMessage({\n        type: 'error',\n        data: 'Invalid type: ' + type\n      });\n      break;\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/worker/engine-worker.js\n// module id = 388\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/worker/engine-worker.js?")},389:/*!*******************************!*\
  !*** ./engine/model/index.js ***!
  \*******************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(/*! ./Model */ 390);\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/index.js\n// module id = 389\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/model/index.js?")},390:/*!*******************************!*\
  !*** ./engine/model/Model.js ***!
  \*******************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar Matrix = __webpack_require__(/*! ../matrix */ 79);\n\nvar lstsq = __webpack_require__(/*! ../regression */ 169).lstsq;\n\nvar statistics = __webpack_require__(/*! ../statistics */ 121);\n\nvar utils = __webpack_require__(/*! ../utils */ 78);\n\nvar perf = __webpack_require__(/*! ../perf */ 203);\n\nvar Observable = __webpack_require__(/*! ../observable */ 391);\n\nvar _require = __webpack_require__(/*! ../labels.json */ 80),\n    FIT_LABEL = _require.FIT_LABEL,\n    CROSS_LABEL = _require.CROSS_LABEL,\n    VALIDATION_LABEL = _require.VALIDATION_LABEL,\n    LOG = _require.LOG,\n    K_ORDER_DIFFERENCE = _require.K_ORDER_DIFFERENCE,\n    STANDARDIZE = _require.STANDARDIZE,\n    RESCALE = _require.RESCALE,\n    DELETE = _require.DELETE;\n\nvar CandidateWorker = __webpack_require__(/*! ./CandidateWorker */ 393);\n\nvar TermPool = __webpack_require__(/*! ./TermPool */ 394);\n\nvar CacheMixin = __webpack_require__(/*! ./CacheMixin */ 261);\n\nvar combos = __webpack_require__(/*! ./combos */ 396);\n\nvar _data = Symbol('data');\n\nvar _exponents = Symbol('exponents');\n\nvar _multiplicands = Symbol('multiplicands');\n\nvar _lags = Symbol('lags');\n\nvar _dependent = Symbol('dependent');\n\nvar _use_cols = Symbol('useCols');\n\nvar _subsets = Symbol('subsets');\n\nvar _terms = Symbol('terms');\n\nvar _cand_workers = Symbol('candWorkers');\n\nvar INTERCEPT = [[0, 0, 0]];\nvar N_CANDIDATE_WORKERS = 8;\n\nvar Model = /*#__PURE__*/function (_CacheMixin) {\n  _inherits(Model, _CacheMixin);\n\n  var _super = _createSuper(Model);\n\n  function Model() {\n    var _this;\n\n    _classCallCheck(this, Model);\n\n    _this = _super.call(this);\n    _this[_data] = {};\n    _this[_data][FIT_LABEL] = new Matrix(0, 0);\n    _this[_exponents] = [1];\n    _this[_multiplicands] = [1];\n    _this[_lags] = [0];\n    _this[_dependent] = 0;\n    _this[_use_cols] = [];\n    _this[_subsets] = {};\n    _this[_subsets][FIT_LABEL] = [];\n\n    try {\n      _this[_cand_workers] = utils.range(0, N_CANDIDATE_WORKERS).map(function () {\n        return new CandidateWorker(_assertThisInitialized(_this));\n      });\n    } catch (e) {\n      // Set this to null so we know workers are unavailable and can fallback\n      // to single-threaded operation\n      _this[_cand_workers] = null;\n    }\n\n    _this.termpool = new TermPool(_assertThisInitialized(_this));\n    _this[_terms] = [_this.termpool.get(INTERCEPT)];\n    return _this;\n  }\n\n  _createClass(Model, [{\n    key: \"clear\",\n    value: function clear() {\n      this[_terms] = [];\n      this.uncache('X');\n      this.uncache('y');\n      this.uncache('highestLag');\n      this.fire('clear');\n      return this;\n    }\n  }, {\n    key: \"transformColumn\",\n    value: function transformColumn(label, data) {\n      var _this2 = this;\n\n      var index = data.index;\n\n      if (index === undefined || isNaN(index)) {\n        return this;\n      }\n\n      var data_labels = data.data_labels || [FIT_LABEL, CROSS_LABEL, VALIDATION_LABEL]; // Need to do this for all dataset and not just \"fit\" data\n      // If clear cross and validation data in UI, doesn't clear respective data in Model, so will throw error\n\n      data_labels.map(function (data_label) {\n        if (_this2[_data][data_label]) {\n          var col = _this2[_data][data_label].col(index);\n\n          switch (label) {\n            case DELETE:\n              _this2.setData(_this2[_data][data_label].delColumn(index), data_label);\n\n              break;\n\n            case LOG:\n              var transform_col = statistics.compute(label, {\n                X: col\n              }); // this[_data][data_label] = this[_data][data_label].appendM(transform_col);\n\n              _this2.setData(_this2[_data][data_label].appendM(transform_col), data_label);\n\n              break;\n\n            case K_ORDER_DIFFERENCE:\n              var k = data.k;\n              var transform_col = statistics.compute(label, {\n                X: col,\n                k: k\n              }); // this[_data][data_label] = this[_data][data_label].appendM(transform_col);\n\n              _this2.setData(_this2[_data][data_label].appendM(transform_col), data_label);\n\n              break;\n\n            case STANDARDIZE:\n              var mean = statistics.compute(\"mean\", {\n                X: col\n              });\n              var std = statistics.compute(\"std\", {\n                X: col,\n                mean: mean\n              });\n              console.log(\"Mean\", mean);\n              console.log(\"Std\", std);\n              var transform_col = statistics.compute(label, {\n                X: col,\n                mean: mean,\n                std: std\n              }); // this[_data][data_label] = this[_data][data_label].appendM(transform_col);\n\n              _this2.setData(_this2[_data][data_label].appendM(transform_col), data_label);\n\n              break;\n\n            case RESCALE:\n              var rms = statistics.compute(\"RMS\", {\n                X: col\n              });\n              var transform_col = statistics.compute(label, {\n                X: col,\n                RMS: rms\n              }); // this[_data][data_label] = this[_data][data_label].appendM(transform_col);\n\n              _this2.setData(_this2[_data][data_label].appendM(transform_col), data_label);\n\n              break;\n\n            default:\n              break;\n          }\n        }\n      });\n      this.fire('dataTransform', {\n        label: label,\n        index: index\n      });\n      return this;\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(data) {\n      var _this3 = this;\n\n      var label = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FIT_LABEL;\n      data = data == null ? undefined : data;\n      label = label == null ? FIT_LABEL : label;\n\n      if (data && !(data instanceof Matrix)) {\n        data = new Matrix(data);\n      }\n\n      if (data) {\n        if (label !== FIT_LABEL && data.shape[1] !== this[_data][FIT_LABEL].shape[1]) {// throw new Error(\n          //   `Data for '${label}' is not the same shape as '${FIT_LABEL}'`\n          // );\n        } else {\n          this[_use_cols] = utils.range(0, data.shape[1]);\n        }\n      }\n\n      var curr_data = this[_data][label];\n      this[_data][label] = data;\n      this[_subsets][label] = data ? utils.range(0, data.shape[0]) : undefined;\n      this[_terms] = this[_terms].map(function (term) {\n        return term.isIntercept ? _this3.termpool.get(INTERCEPT) : term;\n      });\n      this.uncache('X');\n      this.uncache('y');\n      this.uncache('data');\n      this.uncache('highestLag');\n      this.termpool.uncache();\n      this.fire('setData', {\n        data: data,\n        label: label\n      }); // First time importing data\n\n      if (curr_data === undefined && (label == CROSS_LABEL || label == VALIDATION_LABEL) && data && data.shape[1] < this[_data][FIT_LABEL].shape[1]) {\n        this.fire('propogateTransform', {\n          data_label: label\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"getCandidateTerms\",\n    value: function getCandidateTerms() {\n      var _this4 = this;\n\n      // Candidates from exp / mults / lag\n      var independent = this[_use_cols].filter(function (col) {\n        return col !== _this4[_dependent];\n      });\n\n      var candidates = combos.generateTerms(this[_dependent], independent, this[_exponents], this[_multiplicands], this[_lags]).map(this.termpool.get.bind(this.termpool)); // Intercept candidate (column of 1s)\n\n      candidates.unshift(this.termpool.get(INTERCEPT));\n      return candidates;\n    }\n  }, {\n    key: \"getCandidates\",\n    value: function getCandidates() {\n      var _this5 = this;\n\n      if (this[_cand_workers] == null) {\n        return this.getCandidatesSync();\n      }\n\n      this.fire('getCandidates.start');\n      perf.start('get-candidate-terms');\n      var candidates = this.getCandidateTerms();\n      perf.end('get-candidate-terms'); // For each candidate, get the stats for it alongside terms in the model\n      // If using workers, distribute the terms among them\n\n      candidates = candidates.filter(function (cand) {\n        return !_this5[_terms].includes(cand);\n      });\n      var candsPerWorker = utils.split(candidates, this[_cand_workers].length);\n      var progress = utils.zeros(this[_cand_workers].length); // Called by each worker after some number of candidates have been computed\n\n      var onProgress = function onProgress(workerId, numFinished) {\n        progress[workerId] = numFinished;\n\n        _this5.fire('getCandidates.each', {\n          curr: utils.sum(progress),\n          total: candidates.length\n        });\n      }; // Pass a chunk of candidates to each worker to be computed\n\n\n      var workerPromises = candsPerWorker.map(function (cands, i) {\n        return _this5[_cand_workers][i].compute(cands, onProgress);\n      });\n      return Promise.all(workerPromises).then(function (candidates) {\n        _this5.fire('getCandidates.end');\n\n        return utils.join(candidates);\n      });\n    }\n  }, {\n    key: \"getLabelData\",\n    value: function getLabelData(label) {\n      return this[_data][label];\n    }\n  }, {\n    key: \"getModel\",\n    value: function getModel(testLabel) {\n      var highestLag = this.highestLag(),\n          X = this.X().lo(highestLag),\n          y = this.y().lo(highestLag);\n      var stats = statistics(lstsq(X, y)); // If the model we want is not the default label (fit data), compute lstsq\n      // with whichever dataset is requested\n\n      if (testLabel != null) {\n        stats = statistics(lstsq(this.X(testLabel).lo(highestLag), this.y(testLabel).lo(highestLag), stats.weights));\n      }\n\n      var predicted = Array.from(stats.yHat.data);\n\n      var terms = this[_terms].map(function (term, i) {\n        return {\n          term: term.valueOf(),\n          coeff: stats.weights.get(i, 0),\n          stats: {\n            t: stats.t.get(i, 0),\n            pt: stats.pt.get(i, 0)\n          }\n        };\n      });\n\n      var residuals = stats.y.sub(stats.yHat);\n      residuals = residuals.data;\n      return {\n        highestLag: this.highestLag(),\n        terms: terms,\n        stats: stats,\n        predicted: predicted,\n        residuals: residuals\n      };\n    }\n  }, {\n    key: \"getCandidatesSync\",\n    value: function getCandidatesSync() {\n      var _this6 = this;\n\n      this.fire('getCandidates.start');\n      var candidates = this.getCandidateTerms();\n      var results;\n      results = candidates.filter(function (cand) {\n        return !_this6[_terms].includes(cand);\n      }).map(function (candidate, i) {\n        _this6.fire('getCandidates.each', {\n          curr: i,\n          total: candidates.length\n        });\n\n        try {\n          var stats = candidate.getStats();\n          return {\n            term: candidate.valueOf(),\n            coeff: stats.coeff,\n            stats: stats\n          };\n        } catch (e) {\n          return null;\n        }\n      }).filter(function (cand) {\n        return cand != null;\n      });\n      this.fire('getCandidates.end');\n      return Promise.resolve(results);\n    }\n  }, {\n    key: \"setExponents\",\n    value: function setExponents(exponents) {\n      this[_exponents] = exponents.slice();\n      this.fire('setExponents', exponents);\n      return this;\n    }\n  }, {\n    key: \"setMultiplicands\",\n    value: function setMultiplicands(multiplicands) {\n      this[_multiplicands] = utils.range(1, multiplicands + 1);\n      this.fire('setMultiplicands', multiplicands);\n      return this;\n    }\n  }, {\n    key: \"setDependent\",\n    value: function setDependent(dependent) {\n      this[_dependent] = dependent;\n      this[_terms] = [this.termpool.get(INTERCEPT)];\n      this.uncache();\n      this.fire('setDependent', dependent);\n      return this;\n    }\n  }, {\n    key: \"setColumns\",\n    value: function setColumns(cols) {\n      this[_use_cols] = cols.slice();\n      this[_terms] = [this.termpool.get(INTERCEPT)];\n      this.uncache();\n      this.fire('setColumns', cols);\n      return this;\n    }\n  }, {\n    key: \"setLags\",\n    value: function setLags(lags) {\n      if (!lags.every(function (lag) {\n        return lag >= 0;\n      })) {\n        this.fire('error', 'Cannot have negative lag');\n        return this;\n      }\n\n      this[_lags] = lags.slice();\n      this.fire('setLags', lags);\n      return this;\n    }\n  }, {\n    key: \"subset\",\n    value: function subset() {\n      var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : FIT_LABEL;\n      var start = arguments.length > 1 ? arguments[1] : undefined;\n      var end = arguments.length > 2 ? arguments[2] : undefined;\n      this.uncache('X');\n      this.uncache('y');\n      this.uncache('data');\n\n      if (this[_data][label] == null) {\n        throw new ReferenceError('Cannot find data for \\'' + label + '\\'');\n      }\n\n      if (!Array.isArray(start)) {\n        start = utils.range(start, end || this[_data][label].shape[0]);\n      } else {\n        start = start.slice();\n      }\n\n      this[_subsets][label] = start;\n      this.fire('subset', start);\n      return this;\n    }\n  }, {\n    key: \"addTerm\",\n    value: function addTerm(term) {\n      var found = this[_terms].find(function (t) {\n        return t.equals(term);\n      });\n\n      if (!found) {\n        found = this.termpool.get(term);\n\n        this[_terms].push(found);\n\n        this.uncache('X');\n        this.uncache('y');\n      }\n\n      this.uncache('highestLag');\n      this.fire('addTerm', term);\n      return this;\n    }\n  }, {\n    key: \"removeTerm\",\n    value: function removeTerm(term) {\n      this[_terms] = this[_terms].filter(function (t) {\n        return !t.equals(term);\n      });\n      this.uncache('X');\n      this.uncache('y');\n      this.uncache('highestLag');\n      this.fire('removeTerm', term);\n      return this;\n    }\n  }, {\n    key: \"highestLag\",\n    value: function highestLag() {\n      return this[_terms].reduce(function (high, term) {\n        return Math.max(high, term.lag);\n      }, 0);\n    }\n  }, {\n    key: \"X\",\n    value: function X() {\n      var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : FIT_LABEL;\n\n      if (this[_data][label] == null) {\n        throw new ReferenceError('Cannot find data for \\'' + label + '\\'');\n      }\n\n      return this[_terms].reduce(function (prev, curr) {\n        return prev.hstack(curr.col(label));\n      }, new Matrix(this[_subsets][label].length, 0));\n    }\n  }, {\n    key: \"y\",\n    value: function y() {\n      var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : FIT_LABEL;\n      return this.data(label).subset(':', this[_dependent]);\n    }\n  }, {\n    key: \"data\",\n    value: function data() {\n      var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : FIT_LABEL;\n\n      if (this[_data][label] == null) {\n        throw new ReferenceError('Cannot find data for \\'' + label + '\\'');\n      }\n\n      return this[_data][label].subset(this[_subsets][label]);\n    }\n  }, {\n    key: \"computeSensitivity\",\n    value: function computeSensitivity(index) {\n      var label = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FIT_LABEL;\n\n      if (index == undefined) {\n        return this;\n      }\n\n      var model = this; // to use within loops below\n\n      var num_rows = model[_data][FIT_LABEL].shape[0];\n      var derivative = new Matrix(num_rows, 1, new Array(num_rows).fill(0));\n      this.terms.forEach(function (t) {\n        var contains_variable = false; // Check if the variable we are deriving on is in this term\n\n        var derivative_part = new Matrix(num_rows, 1, new Array(num_rows).fill(1)); // One coefficient per term\n\n        var term_coef = 2 * t.getStats()['coeff']; // t.valueOf() is an Array which contains information for each variable of the term\n\n        var tValues = t.valueOf();\n        tValues.forEach(function (tValue) {\n          var current_index = tValue[0];\n          var current_exp = tValue[1]; // Get the current column of data\n\n          var current_col = model[_data][label].col(current_index)['data'];\n\n          var part;\n\n          if (current_index == index) {\n            // Current variable exists in term, should be used in derivative\n            contains_variable = true; // current_exp * [COLUMN DATA]^(current_exp - 1)\n\n            part = statistics.compute('sensitivity_part', {\n              data: current_col,\n              exp: current_exp,\n              derivative: true\n            });\n          } else {\n            // [COLUMN DATA]^(current_exp)\n            part = statistics.compute('sensitivity_part', {\n              data: current_col,\n              exp: current_exp,\n              derivative: false\n            });\n          }\n\n          derivative_part = derivative_part.dotMultiply(new Matrix(num_rows, 1, part));\n        });\n\n        if (contains_variable) {\n          // Add to overall derivative\n          derivative = derivative.add(derivative_part.dotMultiply(term_coef));\n        }\n      });\n      return {\n        index: index,\n        sensitivity: derivative.data\n      };\n    }\n  }, {\n    key: \"getSensitivity\",\n    value: function getSensitivity(index) {\n      var label = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FIT_LABEL;\n      var res = this.computeSensitivity(index, label);\n      this.fire('getSensitivity', res);\n      return this;\n    }\n  }, {\n    key: \"deleteSensitivity\",\n    value: function deleteSensitivity(index) {\n      this.fire('deleteSensitivity', {\n        index: index\n      });\n      return this;\n    }\n  }, {\n    key: \"updateSensitivity\",\n    value: function updateSensitivity(index) {\n      var label = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FIT_LABEL;\n      var res = this.computeSensitivity(index, label);\n      this.fire('updateSensitivity', res);\n      return this;\n    }\n  }, {\n    key: \"computeImportanceRatio\",\n    value: function computeImportanceRatio(index) {\n      var label = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FIT_LABEL;\n\n      if (index == undefined) {\n        return this;\n      }\n\n      var model = this;\n      var num_rows = model[_data][FIT_LABEL].shape[0];\n\n      var current_col = model[_data][label].col(index);\n\n      var dependent_col = model[_data][label].col(model[_dependent]);\n\n      var sensitivity = this.computeSensitivity(index, label)['sensitivity']; // Convert to matrix\n\n      sensitivity = new Matrix(num_rows, 1, sensitivity); // Compute Standard Deviation of independent variable\n\n      var mean_x = statistics.compute('mean', {\n        X: current_col\n      });\n      var std_x = statistics.compute('std', {\n        X: current_col,\n        mean: mean_x\n      }); // Compute Standard Deviation of dependent variable\n\n      var mean_y = statistics.compute('mean', {\n        X: dependent_col\n      });\n      var std_y = statistics.compute('std', {\n        X: dependent_col,\n        mean: mean_y\n      });\n      var importance_ratio = sensitivity.dotMultiply(std_x / std_y);\n      return {\n        index: index,\n        importanceRatio: importance_ratio.data\n      };\n    }\n  }, {\n    key: \"getImportanceRatio\",\n    value: function getImportanceRatio(index) {\n      var label = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FIT_LABEL;\n      var res = this.computeImportanceRatio(index, label);\n      this.fire('getImportanceRatio', res);\n      return this;\n    }\n  }, {\n    key: \"deleteImportanceRatio\",\n    value: function deleteImportanceRatio(index) {\n      this.fire('deleteImportanceRatio', {\n        index: index\n      });\n      return this;\n    }\n  }, {\n    key: \"updateImportanceRatio\",\n    value: function updateImportanceRatio(index) {\n      var label = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FIT_LABEL;\n      var res = this.computeImportanceRatio(index, label);\n      this.fire('updateImportanceRatio', res);\n      return this;\n    }\n  }, {\n    key: \"labels\",\n    get: function get() {\n      var _this7 = this;\n\n      return Object.keys(this[_subsets]).filter(function (data_label) {\n        return _this7[_subsets][data_label];\n      });\n    }\n  }, {\n    key: \"terms\",\n    get: function get() {\n      return this[_terms].slice();\n    }\n  }]);\n\n  return Model;\n}(CacheMixin(Observable));\n\nCacheMixin.cache(Model, 'highestLag');\nCacheMixin.cache(Model, 'X', [FIT_LABEL]);\nCacheMixin.cache(Model, 'y', [FIT_LABEL]);\nCacheMixin.cache(Model, 'data', [FIT_LABEL]);\nmodule.exports = Model;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/Model.js\n// module id = 390\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/model/Model.js?")},391:/*!************************************!*\
  !*** ./engine/observable/index.js ***!
  \************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(/*! ./Observable */ 392);\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/observable/index.js\n// module id = 391\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/observable/index.js?")},392:/*!*****************************************!*\
  !*** ./engine/observable/Observable.js ***!
  \*****************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports){eval('function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _events = Symbol(\'events\');\n\nvar _listeners = Symbol(\'listeners\');\n\nvar _listenerCount = Symbol(\'listenerCount\');\n\nvar Observable = /*#__PURE__*/function () {\n  function Observable() {\n    _classCallCheck(this, Observable);\n\n    this[_events] = {};\n    this[_listeners] = {};\n    this[_listenerCount] = 0;\n  }\n\n  _createClass(Observable, [{\n    key: "on",\n    value: function on(event, handler) {\n      var _this = this;\n\n      // If an array of events, register for each event\n      if (Array.isArray(event)) {\n        return event.map(function (ev) {\n          return _this.on(ev, handler);\n        });\n      } // Otherwise, register the sole event\n\n\n      var id = this[_listenerCount] += 1;\n      this[_listeners][id] = handler;\n\n      if (!this[_events][event]) {\n        this[_events][event] = [];\n      }\n\n      this[_events][event].push(id);\n\n      return id;\n    }\n  }, {\n    key: "removeListener",\n    value: function removeListener(id) {\n      var _this2 = this;\n\n      // If an array of ids, unregister for each id\n      if (Array.isArray(id)) {\n        return id.every(function (ev) {\n          return _this2.removeListener(ev, id);\n        });\n      }\n\n      delete this[_listeners][id];\n      Object.keys(this[_events]).forEach(function (event) {\n        return _this2[_events][event] = _this2[_events][event].filter(function (handlerId) {\n          return handlerId !== id;\n        });\n      });\n      return true;\n    }\n  }, {\n    key: "fire",\n    value: function fire(event, data) {\n      var _this3 = this;\n\n      if (!this[_events][event]) {\n        this[_events][event] = [];\n      }\n\n      this[_events][event].forEach(function (id) {\n        return _this3[_listeners][id](data);\n      });\n    }\n  }]);\n\n  return Observable;\n}();\n\nmodule.exports = Observable;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/observable/Observable.js\n// module id = 392\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/observable/Observable.js?')},393:/*!*****************************************!*\
  !*** ./engine/model/CandidateWorker.js ***!
  \*****************************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*global Worker*/\nvar _require = __webpack_require__(/*! ../labels.json */ 80),\n    FIT_LABEL = _require.FIT_LABEL,\n    CROSS_LABEL = _require.CROSS_LABEL,\n    VALIDATION_LABEL = _require.VALIDATION_LABEL; //const CandidateWorkerScript       = require('../worker/candidate-worker.js');\n\n\nvar perf = __webpack_require__(/*! ../perf */ 203);\n\nvar randomId = function randomId() {\n  return Math.floor(Math.random() * 1e16).toString(16);\n};\n\nvar counter = function () {\n  var next = 0;\n  return function () {\n    return next += 1;\n  };\n}();\n\nfunction unwrapMatrix(matrix) {\n  return {\n    m: matrix.shape[0],\n    n: matrix.shape[1],\n    data: matrix.data\n  };\n}\n\nvar CandidateWorker = /*#__PURE__*/function () {\n  function CandidateWorker(model) {\n    _classCallCheck(this, CandidateWorker);\n\n    if (typeof Worker === 'undefined' || !Worker) {\n      throw new Error('Web workers unavailable');\n    }\n\n    this.id = counter();\n    this.worker = new Worker('candidate-worker.js');\n    this.model = model;\n  }\n\n  _createClass(CandidateWorker, [{\n    key: \"compute\",\n    value: function compute(candidates, update) {\n      var _this = this;\n\n      var thisJobId = randomId();\n      return new Promise(function (resolve, reject) {\n        _this.worker.addEventListener('message', function (_ref) {\n          var _ref$data = _ref.data,\n              data = _ref$data.data,\n              type = _ref$data.type,\n              jobId = _ref$data.jobId;\n\n          if (jobId !== thisJobId) {\n            return;\n          }\n\n          switch (type) {\n            case 'progress':\n              update && update(_this.id, data);\n              break;\n\n            case 'result':\n              resolve(data.map(function (stats, i) {\n                return {\n                  term: candidates[i].valueOf(),\n                  coeff: stats.coeff,\n                  stats: stats\n                };\n              }));\n              perf.end('candidate-worker');\n              break;\n\n            default:\n              console.error(\"[CandidateWorker\".concat(_this.id, \"]: Invalid type '\").concat(type, \"'\"));\n              break;\n          }\n        });\n\n        perf.start('candidate-worker'); // 2d array of each column and its values\n\n        var transferables = [];\n        var fit = {\n          X: unwrapMatrix(_this.model.X(FIT_LABEL)),\n          y: unwrapMatrix(_this.model.y(FIT_LABEL))\n        };\n        var cross;\n        var validation;\n\n        try {\n          cross = {\n            X: unwrapMatrix(_this.model.X(CROSS_LABEL)),\n            y: unwrapMatrix(_this.model.y(CROSS_LABEL))\n          };\n        } catch (e) {\n          cross = fit;\n        }\n\n        try {\n          validation = {\n            X: unwrapMatrix(_this.model.X(VALIDATION_LABEL)),\n            y: unwrapMatrix(_this.model.y(VALIDATION_LABEL))\n          };\n        } catch (e) {\n          validation = fit;\n        }\n\n        var unwrappedCandidates = candidates.map(function (term) {\n          var fit;\n\n          try {\n            fit = unwrapMatrix(term.col(FIT_LABEL));\n          } catch (e) {}\n\n          var lag = Math.max(_this.model.highestLag(), term.lag);\n          var cross;\n          var validation;\n\n          try {\n            cross = unwrapMatrix(term.col(CROSS_LABEL));\n            validation = unwrapMatrix(term.col(VALIDATION_LABEL));\n          } catch (e) {\n            cross = fit;\n            validation = fit;\n          }\n\n          if (fit) {\n            transferables.push(fit.data, cross.data);\n            transferables.push(fit.data, validation.data);\n          }\n\n          return {\n            fit: fit,\n            lag: lag,\n            cross: cross,\n            validation: validation\n          };\n        });\n\n        _this.worker.postMessage({\n          fit: fit,\n          cross: cross,\n          validation: validation,\n          candidates: unwrappedCandidates,\n          jobId: thisJobId\n        }, transferables);\n      });\n    }\n  }]);\n\n  return CandidateWorker;\n}();\n\nmodule.exports = CandidateWorker;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/CandidateWorker.js\n// module id = 393\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/model/CandidateWorker.js?")},394:/*!**********************************!*\
  !*** ./engine/model/TermPool.js ***!
  \**********************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){eval('function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Term = __webpack_require__(/*! ./Term */ 395);\n\nvar TermPool = /*#__PURE__*/function () {\n  function TermPool(model) {\n    _classCallCheck(this, TermPool);\n\n    this.model = model;\n    this.terms = {};\n  }\n\n  _createClass(TermPool, [{\n    key: "get",\n    value: function get(term) {\n      var found = this.terms[Term.hash(term)];\n\n      if (!found) {\n        found = new Term(this.model, term);\n        this.terms[Term.hash(found.valueOf())] = found;\n      }\n\n      return found;\n    }\n  }, {\n    key: "uncache",\n    value: function uncache() {\n      Object.values(this.terms).forEach(function (term) {\n        return term.uncache(\'col\');\n      });\n    }\n  }]);\n\n  return TermPool;\n}();\n\nmodule.exports = TermPool;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/TermPool.js\n// module id = 394\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/model/TermPool.js?')},395:/*!******************************!*\
  !*** ./engine/model/Term.js ***!
  \******************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar CacheMixin = __webpack_require__(/*! ./CacheMixin */ 261);\n\nvar statistics = __webpack_require__(/*! ../statistics */ 121);\n\nvar lstsq = __webpack_require__(/*! ../regression */ 169).lstsq;\n\nvar Matrix = __webpack_require__(/*! ../matrix */ 79);\n\nvar _require = __webpack_require__(/*! ../labels.json */ 80),\n    FIT_LABEL = _require.FIT_LABEL,\n    CROSS_LABEL = _require.CROSS_LABEL;\n/**\n * Private members\n *\n * @private\n */\n\n\nvar _parts = Symbol(\'parts\');\n\nvar _model = Symbol(\'model\');\n/**\n * Term is a combination of input columns, exponents, and lags, such as x^2*y^3.\n *\n * @class Term\n */\n\n\nvar Term = /*#__PURE__*/function (_CacheMixin) {\n  _inherits(Term, _CacheMixin);\n\n  var _super = _createSuper(Term);\n\n  /**\n   * Creates a new Term.\n   *\n   * @constructor\n   * @param {Model}             model         Model that owns this Term\n   * @param {[num, num, num][]} parts         List of triples of numbers\n   * @param {number}            parts[i][0]   First is the index of a column\n   * @param {number}            parts[i][1]   Second is the exponent to raise\n   *                                          that column to\n   * @param {number}           [parts[i][2]]  Third is the lag to apply to that\n   *                                          column\n   */\n  function Term(model, parts) {\n    var _this;\n\n    _classCallCheck(this, Term);\n\n    _this = _super.call(this);\n\n    if (!parts.every(Array.isArray)) {\n      throw new TypeError(\'Part does not match: [col, exp (,lag)]\');\n    }\n\n    _this[_parts] = parts.map(function (part) {\n      if (part.length < 2) {\n        throw new TypeError(\'Part does not match: [col, exp (,lag)]\');\n      }\n\n      if (part.length < 3) {\n        return part.concat(0);\n      }\n\n      return part.slice();\n    });\n    _this[_model] = model;\n    _this.isIntercept = parts[0][0] === 0 && parts[0][1] === 0 && parts.length === 1;\n\n    try {\n      _this.col();\n    } catch (e) {// TODO: Pass up errors so that suspicious columns can be marked\n    }\n\n    return _this;\n  }\n  /**\n   * Computes least squares regression and analysis statistics on the parent\n   * model PLUS this term.\n   *\n   * @return {t: number, mse: number} Statistics for the regression\n   */\n\n\n  _createClass(Term, [{\n    key: "getStats",\n    value: function getStats() {\n      try {\n        // If we have cross data, use that to compute stats on lstsq\n        // Otherwise, just use the fit data\n        var regression = lstsq(this.X(FIT_LABEL), this.y(FIT_LABEL));\n        var stats = statistics(regression);\n        var t = stats.t.get(0, stats.t.shape[0] - 1);\n        var pt = stats.pt.get(0, stats.pt.shape[0] - 1);\n        Object.assign(regression, {\n          X: this.X(CROSS_LABEL),\n          y: this.y(CROSS_LABEL)\n        });\n        stats = statistics(regression);\n        stats.coeff = stats.weights.get(0, stats.weights.shape[0] - 1);\n        stats.t = t;\n        stats.pt = pt;\n        delete stats.weights;\n        return stats;\n      } catch (e) {\n        console.error(e);\n        return NaN;\n      }\n    }\n  }, {\n    key: "X",\n    value: function X() {\n      var subset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : FIT_LABEL;\n      var lag = Math.max(this[_model].highestLag(), this.lag);\n\n      try {\n        return this[_model].X(subset).hstack(this.col(subset)).lo(lag);\n      } catch (e) {\n        if (subset !== FIT_LABEL) {\n          return this.X(FIT_LABEL);\n        }\n\n        throw e;\n      }\n    }\n  }, {\n    key: "y",\n    value: function y() {\n      var subset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : FIT_LABEL;\n      var lag = Math.max(this[_model].highestLag(), this.lag);\n\n      try {\n        return this[_model].y(subset).lo(lag);\n      } catch (e) {\n        if (subset !== FIT_LABEL) {\n          return this.y(FIT_LABEL);\n        }\n\n        throw e;\n      }\n    }\n    /**\n     * Determines if this term is equivalent to `other`.\n     *\n     * @param {Term | [num, num, num][]}  other Term to compare against\n     * @return {boolean} True if the terms are equivalent, false otherwise\n     */\n\n  }, {\n    key: "equals",\n    value: function equals(other) {\n      other = other.valueOf().map(function (part) {\n        part = part.concat(0);\n        part.length = 3;\n        return part;\n      });\n      return Term.hash(other) === Term.hash(this);\n    }\n    /**\n     * Returns the information necessary to reconstruct the term in a plain\n     * object (except the reference to the model).\n     *\n     * @return {[num, num, num][]} List of [col, exp, lag] triples\n     */\n\n  }, {\n    key: "valueOf",\n    value: function valueOf() {\n      return this[_parts].slice();\n    }\n    /**\n     * Compute the data column for a given matrix.\n     *\n     * @return {Matrix<n,1>} n x 1 Matrix -- polynomial combo of columns in term\n     */\n\n  }, {\n    key: "col",\n    value: function col() {\n      var subset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : FIT_LABEL;\n\n      try {\n        var data = this[_model].data(subset),\n            prod = Matrix.zeros(data.shape[0], 1).add(1),\n            i,\n            col;\n\n        for (i = 0; i < this[_parts].length; i += 1) {\n          col = data.col(this[_parts][i][0]); // Check for negative exponent & potential 0 value\n\n          if (col.max() * col.min() <= 0 && this[_parts][i][1] < 0) {\n            throw new Error("Divide by zero error for column ".concat(this[_parts][i][0]));\n          }\n\n          prod = prod.dotMultiply(col.dotPow(this[_parts][i][1]).shift(this[_parts][i][2]));\n        }\n\n        return prod;\n      } catch (e) {\n        if (subset !== FIT_LABEL) {\n          return this.col(FIT_LABEL);\n        }\n\n        throw e;\n      }\n    }\n  }, {\n    key: "inspect",\n\n    /**\n     * Give a representation of the term in a pretty format.\n     *\n     * @return {string} Representation of this term\n     */\n    value: function inspect(depth, options) {\n      return \'Term < \' + this[_parts].map(function (t) {\n        return String.fromCharCode(t[0] + 97) + \'^\' + t[1] + \'[\' + t[2] + \']\';\n      }).join(\' * \') + \' >\';\n    }\n  }, {\n    key: "lag",\n    get: function get() {\n      return Math.max.apply(null, this[_parts].map(function (part) {\n        return part[2];\n      }));\n    }\n  }], [{\n    key: "hash",\n    value: function hash(term) {\n      return term.valueOf().map(function (part) {\n        return "(".concat(part.concat(0).slice(0, 3).toString(), ")");\n      }).toString();\n    }\n  }]);\n\n  return Term;\n}(CacheMixin());\n\nCacheMixin.cache(Term, \'col\', [FIT_LABEL]);\nmodule.exports = Term;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/Term.js\n// module id = 395\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/model/Term.js?')},396:/*!********************************!*\
  !*** ./engine/model/combos.js ***!
  \********************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(/*! ../utils */ 78);\n/**\n * Generate all combinations of k terms.\n *\n * @param {*[]}     terms         Array of items to combine\n * @param {number}  k             # of items in every combination\n * @param {boolean} [replacement] If true, an item from `terms` can be repeated\n *                                in a single combination\n */\n\n\nvar combinations = function combinations(terms, k, replacement) {\n  var combos = [];\n  var i;\n\n  if (k < 1) {\n    return combos;\n  }\n\n  if (k === 1) {\n    return terms.map(function (term) {\n      return [term];\n    });\n  }\n\n  for (i = 0; i < terms.length; i += 1) {\n    var subCombos = combinations( // with replacements    => slice at i (include the current term)\n    // without replacements => slice at i + 1 (exclude current term)\n    terms.slice(i + !replacement), k - 1, replacement); // prepend the current term to each sub combo\n\n    combos = combos.concat(subCombos.map(function (combo) {\n      return [terms[i]].concat(combo);\n    }));\n  }\n\n  return combos;\n};\n/**\n * Generates all combinations of k items using one item from each bin in `bins`.\n *\n *    bins = [[0, 1], [2, 3]], k = 2\n *  ->[[0, 2], [0, 3], [1, 2], [1, 3]]\n *\n *\n * @param {*[][]} bins  An array of arrays containing items. For each\n *                      combination, only one item from each bin can be present\n * @return {*[][]} Combos\n */\n\n\nvar combinationsFromBins = function combinationsFromBins(bins, k) {\n  var combos = [];\n  var i;\n\n  if (k < 1) {\n    return combos;\n  }\n\n  if (bins.length <= 0) {\n    return combos;\n  }\n\n  if (k === 1) {\n    return utils.join(bins).map(function (term) {\n      return [term];\n    });\n  }\n\n  for (i = 0; i < bins[0].length; i += 1) {\n    var subCombos = combinationsFromBins(bins.slice(1), k - 1);\n    combos = combos.concat(subCombos.map(function (combo) {\n      return [bins[0][i]].concat(combo);\n    }));\n  }\n\n  return combos.concat(combinationsFromBins(bins.slice(1), k));\n};\n/**\n * Generates all possible combinations of exponentiated terms given a list of\n * exponents, a list of # of multiplicands, and a list of lags\n *\n * @param {number[]}  dep         Dependent column index from the dataset\n * @param {number[]}  indep       Independent column indices from the dataset\n * @param {number[]}  exponents   Array of exponents ([1, 2] means x, x^2)\n * @param {number[]}  multipliers Array of # of multiplicands ([1] means only\n *                                one multiplicand per term)\n * @param {number[]}  lags        Array of lags (similar to exponents)\n * @return {[number, number][][]} List of terms\n */\n\n\nvar generateTerms = function generateTerms(dep, indep, exponents, multipliers, lags) {\n  var bins = indep.map(function (i) {\n    return utils.join(exponents.map(function (e) {\n      return lags.map(function (l) {\n        return [i, e, l];\n      });\n    }));\n  }); // Include dependent column, but only with lag > 0\n\n  lags = lags.filter(function (l) {\n    return l > 0;\n  });\n  bins.unshift(utils.join(exponents.map(function (e) {\n    return lags.map(function (l) {\n      return [dep, e, l];\n    });\n  })));\n  var combosForMults = utils.join(multipliers.map(function (m) {\n    return combinationsFromBins(bins, m);\n  }));\n  return combosForMults;\n};\n\nmodule.exports.generateTerms = generateTerms;\nmodule.exports.combinations = combinations;\nmodule.exports.combinationsFromBins = combinationsFromBins;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/combos.js\n// module id = 396\n// module chunks = 1\n\n//# sourceURL=webpack:///./engine/model/combos.js?")},78:/*!*************************!*\
  !*** ./engine/utils.js ***!
  \*************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction nchars(n, _char) {\n  n = Math.max(0, n);\n  return Array(n + 1).join(_char);\n}\n\nvar nspaces = function nspaces(n) {\n  return nchars(n, ' ');\n};\n\nfunction pad(width, val) {\n  val = val || '';\n  return nspaces(width - ('' + val).length) + val;\n}\n\nvar range = module.exports.range = function (start, end) {\n  if (start >= end) {\n    return [];\n  }\n\n  return Array(end - start).join(' ').split(' ').map(function (_, i) {\n    return i + start;\n  });\n};\n\nvar zeros = module.exports.zeros = function (n) {\n  return Array(n).join(' ').split(' ').map(function () {\n    return 0;\n  });\n};\n\nvar sum = module.exports.sum = function (arr) {\n  return arr.reduce(function (tot, curr) {\n    return tot + curr;\n  });\n};\n\nmodule.exports.convertRange = function (str, length) {\n  var range, start, end;\n\n  if (typeof str === 'number') {\n    return str < 0 ? [length + str] : [str];\n  }\n\n  if (typeof str !== 'string') {\n    return str.map(function (ind) {\n      return ind < 0 ? length + ind : ind;\n    });\n  }\n\n  if ((range = str.split(':')).length > 1) {\n    start = parseInt(range[0]) || 0;\n    end = parseInt(range[1]) || length;\n\n    if (start < 0) {\n      start = length + start;\n    }\n\n    if (end < 0) {\n      end = length + end;\n    }\n\n    return module.exports.range(start, end);\n  }\n\n  throw new TypeError('Invalid range');\n};\n\nmodule.exports.formatNum = function (leftwidth, rightwidth, val) {\n  var nilDecimalChar = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ' ';\n  val = '' + val;\n  var match = val.match(/(NaN|-?Infinity|-?\\d*)\\.?(\\d*)/),\n      whole = match[1],\n      frac = match[2],\n      repr = '';\n\n  if (frac.length > rightwidth) {\n    frac = frac.slice(0, rightwidth);\n  }\n\n  repr += nspaces(leftwidth - whole.length) + whole;\n\n  if (frac !== '' || rightwidth > 0) {\n    repr += '.';\n    repr += frac.slice(0, rightwidth) + nchars(rightwidth - frac.length, nilDecimalChar);\n  } else {\n    repr += nspaces(rightwidth + 1);\n  }\n\n  return repr;\n};\n\nvar padAll = module.exports.padAll = function (lwidth, str) {\n  if (Array.isArray(str)) {\n    return str.map(function (s) {\n      return padAll(lwidth + s.length, s);\n    });\n  } else if (typeof str === 'string') {\n    return str.split('\\n').map(function (s) {\n      return pad(lwidth + s.length, s);\n    }).join('\\n');\n  }\n\n  return pad(lwidth, str);\n};\n\nvar clone = module.exports.clone = function (obj) {\n  if (_typeof(obj) !== 'object') {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(clone);\n  }\n\n  var newObj = {};\n  Object.keys(obj).forEach(function (key) {\n    return newObj[key] = clone(obj[key]);\n  });\n  return newObj;\n};\n\nvar split = module.exports.split = function (arr, n) {\n  var results = range(0, n).map(function () {\n    return [];\n  });\n  var i;\n\n  for (i = 0; i < arr.length; i += 1) {\n    results[i % n].push(arr[i]);\n  }\n\n  return results;\n};\n\nvar splitToSize = module.exports.splitToSize = function (arr, n) {\n  var results = [];\n  var subset;\n  var i;\n\n  for (i = 0, subset = []; i < arr.length; i += 1) {\n    subset.push(arr[i]);\n\n    if ((i + 1) % n === 0) {\n      results.push(subset);\n      subset = [];\n    }\n  }\n\n  if (i % n !== 0) {\n    results.push(subset);\n  }\n\n  return results;\n};\n\nmodule.exports.join = function (arr) {\n  return [].concat.apply([], arr);\n};\n\nmodule.exports.sign = function (x) {\n  return x < 0 ? -1 : x > 0 ? 1 : 0;\n};\n\nmodule.exports.argmax = function (arr) {\n  return arr.indexOf(Math.max.apply(null, arr));\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/utils.js\n// module id = 78\n// module chunks = 0 1 2\n\n//# sourceURL=webpack:///./engine/utils.js?")},79:/*!********************************!*\
  !*** ./engine/matrix/index.js ***!
  \********************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(/*! ./Matrix */ 204);\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/matrix/index.js\n// module id = 79\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/matrix/index.js?")},80:/*!****************************!*\
  !*** ./engine/labels.json ***!
  \****************************/
/*! dynamic exports provided */
/*! all exports used */
function(module,exports){eval('module.exports = {"FIT_LABEL":"fit","CROSS_LABEL":"cross","VALIDATION_LABEL":"validation","LOG":"log","K_ORDER_DIFFERENCE":"k_order_difference","STANDARDIZE":"standardize","RESCALE":"rescale","DELETE":"delete"}\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/labels.json\n// module id = 80\n// module chunks = 0 1\n\n//# sourceURL=webpack:///./engine/labels.json?')}});